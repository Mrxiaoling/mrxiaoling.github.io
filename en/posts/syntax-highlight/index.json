[{"content":"Markdownify box This is boxmd shortcode Simple box This is **box** shortcode\r Code tabs Make it easy to switch between different code\njava\rjavascript\r\r1  System.out.println(\u0026#39;Hello World!\u0026#39;);\r  \r\r1  console.log(\u0026#39;Hello World!\u0026#39;);\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"c3a7395d19726e47\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r Tabs for general purpose Windows\rMacOS\rUbuntu\r\rWindows section 1  console.log(\u0026#39;Hello World!\u0026#39;);\r  ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n\rMacOS section Hello world!\r\rUbuntu section Great!\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"5c92b60c8ec7870a\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r Expand \r\rExpand me\r\rTitle contents\r\r \r\rExpand me2\r\rTitle2 contents2\r\r Alert Colored box\nthis is a text\rthis is a text\rthis is a text\rthis is a text\rNotice success text\r info text\r warning text\r error text\r ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":2,"section":"posts","tags":["shortcode"],"title":"Shortcodes","uri":"https://mrxiaoling.github.io/en/posts/shortcodes/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":3,"section":"posts","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://mrxiaoling.github.io/en/posts/markdown-syntax/"},{"content":"Code Syntax Highlighting Verify the following code blocks render as code blocks and highlight properly.\nMore about tuning syntax highlighting is the Hugo documentation.\nDiff 1 2 3 4 5 6 7 8 9 10  *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39;\r--- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39;\r***************\r*** 1 ****\r! This is a line.\r--- 1 ---\r! This is a replacement line.\rIt is important to spell\r-removed line\r+new line\r  *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39;\r--- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39;\r***************\r*** 1 ****\r! This is a line.\r--- 1 ---\r! This is a replacement line.\rIt is important to spell\r-removed line\r+new line\rMakefile CC=gcc\rCFLAGS=-I.\rhellomake: hellomake.o hellofunc.o\r$(CC) -o hellomake hellomake.o hellofunc.o -I.\r1 2 3 4 5  CC=gcc\rCFLAGS=-I.\rhellomake: hellomake.o hellofunc.o\r$(CC) -o hellomake hellomake.o hellofunc.o -I.\r  JSON 1 2 3  {\u0026#34;employees\u0026#34;:[\r{\u0026#34;firstName\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Doe\u0026#34;},\r]}\r  Markdown 1 2 3  **bold** *italics* [link](www.example.com)\r  JavaScript 1  document.write(\u0026#39;Hello, world!\u0026#39;);\r  CSS 1 2 3  body {\rbackground-color: red;\r}\r  Objective C 1 2 3 4 5 6  #import \u0026lt;stdio.h\u0026gt;\r\rint main (void)\r{\rprintf (\u0026#34;Hello world!\\n\u0026#34;);\r}\r  Python 1  print \u0026#34;Hello, world!\u0026#34;\r  XML 1 2 3 4 5  \u0026lt;employees\u0026gt;\r\u0026lt;employee\u0026gt;\r\u0026lt;firstName\u0026gt;John\u0026lt;/firstName\u0026gt; \u0026lt;lastName\u0026gt;Doe\u0026lt;/lastName\u0026gt;\r\u0026lt;/employee\u0026gt;\r\u0026lt;/employees\u0026gt;\r  Perl 1  print \u0026#34;Hello, World!\\n\u0026#34;;\r  Bash 1  echo \u0026#34;Hello World\u0026#34;\r  PHP 1  \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;   CoffeeScript 1  console.log(“Hello world!”);\r  C# 1 2 3 4 5 6 7 8  using System;\rclass Program\r{\rpublic static void Main(string[] args)\r{\rConsole.WriteLine(\u0026#34;Hello, world!\u0026#34;);\r}\r}\r  C++ 1 2 3 4 5 6 7  #include \u0026lt;iostream.h\u0026gt;\r\rmain()\r{\rcout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;;\rreturn 0;\r}\r  SQL 1 2  SELECT column_name,column_name\rFROM table_name;\r  Go 1 2 3 4 5  package main\rimport \u0026#34;fmt\u0026#34;\rfunc main() {\rfmt.Println(\u0026#34;Hello, 世界\u0026#34;)\r}\r  Ruby 1  puts \u0026#34;Hello, world!\u0026#34;\r  Java 1 2 3 4 5 6 7 8 9 10 11 12  import javax.swing.JFrame; //Importing class JFrame\rimport javax.swing.JLabel; //Importing class JLabel\rpublic class HelloWorld {\rpublic static void main(String[] args) {\rJFrame frame = new JFrame(); //Creating frame\r frame.setTitle(\u0026#34;Hi!\u0026#34;); //Setting title frame\r frame.add(new JLabel(\u0026#34;Hello, world!\u0026#34;));//Adding text to frame\r frame.pack(); //Setting size to smallest\r frame.setLocationRelativeTo(null); //Centering frame\r frame.setVisible(true); //Showing frame\r }\r}\r  Latex Equation 1  \\frac{d}{dx}\\left( \\int_{0}^{x} f(u)\\,du\\right)=f(x).\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import {x, y} as p from \u0026#39;point\u0026#39;;\rconst ANSWER = 42;\rclass Car extends Vehicle {\rconstructor(speed, cost) {\rsuper(speed);\rvar c = Symbol(\u0026#39;cost\u0026#39;);\rthis[c] = cost;\rthis.intro = `This is a car runs at\r${speed}.`;\r}\r}\rfor (let num of [1, 2, 3]) {\rconsole.log(num + 0b111110111);\r}\rfunction $initHighlight(block, flags) {\rtry {\rif (block.className.search(/\\bno\\-highlight\\b/) != -1)\rreturn processBlock(block.function, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;;\r} catch (e) {\r/* handle exception */\rvar e4x =\r\u0026lt;div\u0026gt;Example\r\u0026lt;p\u0026gt;1234\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;;\r }\rfor (var i = 0 / 2; i \u0026lt; classes.length; i++) {\r// \u0026#34;0 / 2\u0026#34; should not be parsed as regexp\r if (checkCondition(classes[i]) === undefined)\rreturn /\\d+[\\s/]/g;\r}\rconsole.log(Array.every(classes, Boolean));\r}\rexport $initHighlight;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Hello world\u0026lt;/title\u0026gt;\r\u0026lt;link href=\u0026#39;http://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic\u0026#39; rel=\u0026#39;stylesheet\u0026#39; type=\u0026#39;text/css\u0026#39;\u0026gt;\r\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;index.css\u0026#34; /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;vendor/prism.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;examples.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /*********************************************************\r* General\r*/\rpre[class*=\u0026#34;language-\u0026#34;],\rcode {\rcolor: #5c6e74;\rfont-size: 13px;\rtext-shadow: none;\rfont-family: Consolas, Monaco, \u0026#39;Andale Mono\u0026#39;, \u0026#39;Ubuntu Mono\u0026#39;, monospace;\rdirection: ltr;\rtext-align: left;\rwhite-space: pre;\rword-spacing: normal;\rword-break: normal;\rline-height: 1.5;\rtab-size: 4;\rhyphens: none;\r}\rpre[class*=\u0026#34;language-\u0026#34;]::selection,\rcode::selection {\rtext-shadow: none;\rbackground: #b3d4fc;\r}\r@media print {\rpre[class*=\u0026#34;language-\u0026#34;],\rcode {\rtext-shadow: none;\r}\r}\rpre[class*=\u0026#34;language-\u0026#34;] {\rpadding: 1em;\rmargin: .5em 0;\roverflow: auto;\rbackground: #f8f5ec;\r}\r:not(pre) \u0026gt; code {\rpadding: .1em .3em;\rborder-radius: .3em;\rcolor: #db4c69;\rbackground: #f9f2f4;\r}\r  ","description":"Syntax highlighting test","id":4,"section":"posts","tags":["hugo"],"title":"Syntax highlighting","uri":"https://mrxiaoling.github.io/en/posts/syntax-highlight/"},{"content":"We need goldmark katex entension which is not yet we have: [https://github.com/gohugoio/hugo/issues/6544](https://github.com/gohugoio/hugo/issues/6544)\r Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }}\r{{ partial \u0026quot;math.html\u0026quot; . }}\r{{ end }}\r To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nBlock math:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }\n$$\n","description":"A brief guide to setup KaTeX","id":5,"section":"posts","tags":null,"title":"Math Typesetting","uri":"https://mrxiaoling.github.io/en/posts/math-typesetting/"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji {\rfont-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols;\r}  ","description":"Guide to emoji usage in Hugo","id":6,"section":"posts","tags":["emoji","gamoji","namoji","bamoji","amoji"],"title":"Emoji Support","uri":"https://mrxiaoling.github.io/en/posts/emoji-support/"},{"content":"digraph G {\rsubgraph cluster_0 {\rstyle=filled;\rcolor=lightgrey;\rnode [style=filled,color=white];\ra0 -\u0026gt; a1 -\u0026gt; a2 -\u0026gt; a3;\rlabel = \u0026quot;process #1\u0026quot;;\r}\rsubgraph cluster_1 {\rnode [style=filled];\rb0 -\u0026gt; b1 -\u0026gt; b2 -\u0026gt; b3;\rlabel = \u0026quot;process #2\u0026quot;;\rcolor=blue\r}\rstart -\u0026gt; a0;\rstart -\u0026gt; b0;\ra1 -\u0026gt; b3;\rb2 -\u0026gt; a3;\ra3 -\u0026gt; a0;\ra3 -\u0026gt; end;\rb3 -\u0026gt; end;\rstart [shape=Mdiamond];\rend [shape=Msquare];\r}\r","description":"A hack to put Graphviz on the web.","id":7,"section":"posts","tags":[""],"title":"Viz support","uri":"https://mrxiaoling.github.io/en/posts/test-viz/"},{"content":"{ \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;},\r{\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]},\r{\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;},\r{},\r{\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;}\r]}\r","description":"WaveDrom is a Free and Open Source online digital timing diagram (waveform) rendering engine that uses javascript, HTML5 and SVG to convert a WaveJSON input text description into SVG vector graphics.","id":8,"section":"posts","tags":[""],"title":"Wavedrom support","uri":"https://mrxiaoling.github.io/en/posts/test-wavedrom/"},{"content":"{\r\u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8]\r}]\r}\r}\r{\r\u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [\r{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot;\r},\r{\r\u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;,\r\u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot;\r}\r]\r}\r}\r","description":"Simple yet flexible JavaScript charting for designers \u0026 developers","id":9,"section":"posts","tags":[""],"title":"Chart support","uri":"https://mrxiaoling.github.io/en/posts/test-chartjs/"},{"content":"Alice-\u0026gt;Bob: Hello Bob, how are you?\rNote right of Bob: Bob thinks\rBob--\u0026gt;Alice: I am good thanks!\rTitle: Here is a title\rA-\u0026gt;B: Normal line\rB--\u0026gt;C: Dashed line\rC-\u0026gt;\u0026gt;D: Open arrow\rD--\u0026gt;\u0026gt;A: Dashed open arrow\r","description":"Generates UML sequence diagrams from simple text","id":10,"section":"posts","tags":[""],"title":"JS Sequence Diagram support","uri":"https://mrxiaoling.github.io/en/posts/test-js-sequence-diagrams/"},{"content":"graph TD;\rA--\u0026gt;B;\rA--\u0026gt;C;\rB--\u0026gt;D;\rC--\u0026gt;D;\rsequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail...\rJohn--\u0026gt;Alice: Great!\rJohn-\u0026gt;Bob: How about you?\rBob--\u0026gt;John: Jolly good!\rgraph TD\rA[Hard] --\u0026gt;|Text| B(Round)\rB --\u0026gt; C{Decision}\rC --\u0026gt;|One| D[Result 1]\rC --\u0026gt;|Two| E[Result 2]\rgantt\rsection Section\rCompleted :done, des1, 2014-01-06,2014-01-08\rActive :active, des2, 2014-01-07, 3d\rParallel 1 : des3, after des1, 1d\rParallel 2 : des4, after des1, 1d\rParallel 3 : des5, after des3, 1d\rParallel 4 : des6, after des4, 1d\rclassDiagram\rClass01 \u0026lt;|-- AveryLongClass : Cool\r\u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01\rClass09 --\u0026gt; C2 : Where am i?\rClass09 --* C3\rClass09 --|\u0026gt; Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rclass Class10 {\r\u0026lt;\u0026lt;service\u0026gt;\u0026gt;\rint id\rsize()\r}\rstateDiagram\r[*] --\u0026gt; Still\rStill --\u0026gt; [*]\rStill --\u0026gt; Moving\rMoving --\u0026gt; Still\rMoving --\u0026gt; Crash\rCrash --\u0026gt; [*]\rpie\r\u0026quot;Dogs\u0026quot; : 386\r\u0026quot;Cats\u0026quot; : 85\r\u0026quot;Rats\u0026quot; : 15 ","description":"Generate diagrams, charts, graphs or flows from markdown-like text via javascript.","id":11,"section":"posts","tags":["diagram"],"title":"Mermaid support","uri":"https://mrxiaoling.github.io/en/posts/test-mermaid/"},{"content":"When $a \\ne 0$, there are two solutions to $(ax^2 + bx + c = 0)$ and they are\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$\n","description":"A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works.","id":12,"section":"posts","tags":[""],"title":"MathJax support","uri":"https://mrxiaoling.github.io/en/posts/test-mathjax/"},{"content":"The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\nNote: For inline math to render correctly, your content file extension must be .mmark. See the official mmark site.\nInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\rInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math:\r$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\rBlock math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","description":"KaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.","id":13,"section":"posts","tags":[""],"title":"Katex support","uri":"https://mrxiaoling.github.io/en/posts/test-katex/"},{"content":"st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank]\re=\u0026gt;end: End|future:\u0026gt;http://www.google.com\rop1=\u0026gt;operation: My Operation|past\rop2=\u0026gt;operation: Stuff|current\rsub1=\u0026gt;subroutine: My Subroutine|invalid\rcond=\u0026gt;condition: Yes\ror No?|approved:\u0026gt;http://www.google.com\rc2=\u0026gt;condition: Good idea|rejected\rio=\u0026gt;inputoutput: catch something...|future\rst-\u0026gt;op1(right)-\u0026gt;cond\rcond(yes, right)-\u0026gt;c2\rcond(no)-\u0026gt;sub1(left)-\u0026gt;op1\rc2(yes)-\u0026gt;io-\u0026gt;e\rc2(no)-\u0026gt;op2-\u0026gt;e\r","description":"flowchart.js is a flowchart DSL and SVG render that runs in the browser and terminal. Nodes and connections are defined in separately so that nodes can be reused and connections can be quickly changed.","id":14,"section":"posts","tags":[""],"title":"Flowchart support","uri":"https://mrxiaoling.github.io/en/posts/test-flowchart/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":15,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://mrxiaoling.github.io/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":16,"section":"gallery","tags":null,"title":"Photo","uri":"https://mrxiaoling.github.io/en/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":21,"section":"","tags":null,"title":"About","uri":"https://mrxiaoling.github.io/en/about/"},{"content":"第三章   CSMA\n Carrier Sense Multiple Access ，载波监听多路访问    FCS\n Frame Check Sequence，帧检验序列    PPP\n Point-to-Point Protocol，点对点协议    LCP\n Link Control Protocol    NCP\n Netwotrk Control Protocol    IPCP\n IP Control Protocol    PAP\n Password Authentication Protocol    CHAP\n Challenge Handshake Authentication Protocol    MTU\n Maximum Transmission Unit，最大传输单位    CIDR\n Classless Inter-Domain Routing，无类型域间选路    VLSM\n Variable Length Subnet Masking，可变长子网掩码    DSCP\n Differential Services Codepoint，差分服务代码点    ECN\n Explicit Congestion Notification，显式拥塞通告    ARP\n Address Resolution Protocol，地址解析协议    ACK\n Positive Acknowledgement ，意为以接收    MSL\n maximum segment lifetime .最大分段寿命    MSS\n Maximum Segment Size,最大消息长度    ","description":"","id":25,"section":"posts","tags":null,"title":"","uri":"https://mrxiaoling.github.io/en/posts/%E5%9B%BE%E8%A7%A3tcpip/%E5%90%8D%E8%AF%8D%E7%BC%A9%E5%86%99/"},{"content":"Adapter模式  参考：1.《图解设计模式》\n  在现实生活中，适配器很常见，比如电子产品的供电电压电流都有一个额定值，像直流5V1A，5V2A等，但是家庭用电只能提供交流220V，所以需要一个适配器将交流220Vzhuanhuan 在程序中，经常存在现有的程序无法直接使用，需要做适当的变换后才能使用。这种用于填补现有的程序和所需的程序之间差异的设计模式就是Adapter模式  什么时候使用适配器模式？   很多时候，我们并非从零开始编程，经常会用到现有的类，特别是当现有的类已经被充分测试过，BUG很少，而且用于其他软件时，更愿意将这些类作为组件重复使用。\n  Adapter模式有两种\n   类适配器模式（使用继承的适配器） 对象适配器模式（使用委托的适配器）  JDK里的Adapter模式 java.util.Arrays#asList()\njavax.swing.JTable(TableModel)\njava.io.InputStreamReader(InputStream)\njava.io.OutputStreamWriter(OutputStream)\njavax.xml.bind.annotation.adapters.XmlAdapter#marshal()\njavax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()\n\r\rInputStreamReader\r\rInputStreamReade注释里写道：\n An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified （InputStreamReader是从字节流到字符流的桥梁：它读取字节并使用指定的字节将其解码为字符） \r\r\n\r\rArrays\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14  /**\r* Returns a fixed-size list backed by the specified array. (Changes to\r* the returned list \u0026#34;write through\u0026#34; to the array.) This method acts\r* as bridge between array-based and collection-based APIs, in\r* combination with {@link Collection#toArray}. *返回由指定数组支持的固定大小的列表。此方法与{@link Collection＃toArray}结合使用，\r*充当基于数组的API和基于集合的API之间的桥梁。\r*The returned list is serializable and implements {@link RandomAccess}.\r*/\r@SafeVarargs\r@SuppressWarnings(\u0026#34;varargs\u0026#34;)\rpublic static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) {\rreturn new ArrayList\u0026lt;\u0026gt;(a);\r}\r  \r\r\n类适配器模式 UML类图如下 各部分代码如下 1 2 3 4 5 6 7  /**\r* “需求”接口，比如说“转换为直流12V”\r*/\rpublic interface Print {\rpublic abstract void printWeak() ;\rpublic abstract void printStrong() ;\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /**\r* 现有条件，比如交流220V\r*/\rpublic class Banner {\rprivate String string;\rpublic Banner (String string) {\rthis.string = string ;\r}\rpublic void showWithParen() {\rSystem.out.println(\u0026#34;(\u0026#34; + string + \u0026#34;)\u0026#34;);\r}\rpublic void showWithAster() {\rSystem.out.println(\u0026#34;*\u0026#34; + string + \u0026#34;*\u0026#34;);\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /**\r* 适配器，负责将现有的（Banner）转换成需求（Print）\r*/\rpublic class PrintBanner extends Banner implements Print {\rpublic PrintBanner (String string) {\rsuper(string);\r}\r@Override\rpublic void printWeak() {\rshowWithParen();\r}\r@Override\rpublic void printStrong() {\rshowWithAster();\r}\r}\r  1 2 3 4 5 6 7  public class Main {\rpublic static void main(String[] args) {\rPrint p = new PrintBanner(\u0026#34;Hello\u0026#34;) ;\rp.printStrong();\rp.printWeak();\r}\r}\r  代码分析 在Main类中将PrintBanner类的实例保存在了Print类型的变量中，对Main类的代码而言。Banner类、showWithParen方法和showWithAster方法被完全隐藏起来了，就好比只需要知道设备在5V1A就能正常充电，而220V怎么转换成5V的过程并不关心，这样就可以不用对Main类进行修改的情况下改变Printbanner类的具体实现。\n对象适配器 UML类图如下 各部分代码如下  Main类和Banner同上  1 2 3 4  public abstract class Print {\rpublic abstract void printWeak() ;\rpublic abstract void printStrong() ;\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class PrintBanner extends Print {\rprivate Banner banner;\rpublic PrintBanner (String string) {\rthis.banner = new Banner(string);\r}\r@Override\rpublic void printWeak() {\rbanner.showWithParen();\r}\r@Override\rpublic void printStrong() {\rbanner.showWithAster();\r}\r}\r  可能的应用场景-版本更新与兼容性  软件的生命周期总是伴随版本的升级，在升级的过程中就会出现于旧版本的兼容性问题，这时就可以使用Adapter模式进行兼容，帮助我们同时维护新版本和旧版本。  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":26,"section":"posts","tags":["设计模式"],"title":"Adapter模式","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter%E6%A8%A1%E5%BC%8F/"},{"content":"FactoryMethod模式  参考：1.《图解设计模式》\nhttps://www.cnblogs.com/Bobby0322/p/4179921.html\nhttps://blog.csdn.net/qqqqq1993qqqqq/article/details/77332087\nhttps://blog.csdn.net/w372426096/article/details/78009310\n 模式定义  工厂方法模式又称为工厂模式，也叫虚拟构造器（Virtual Constructor）模式或者多态工厂模式（Polymorphic Factory） ; 父类负责定义创建对象的公共接口**，而子类则负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成，即由子类来决定究竟应该实例化（创建）哪一个类**。  解决何种问题   在简单工厂模式中，将实例化对象的工作推迟到了专门负责创建对象的工厂类中，这样，在我们事先预知的情况下，可以根据我们的需要动态创建产品类。；\n  但是，我们的预知是有限的，客户的变化可能是无限的。所以，就出现了问题，一旦客户的变化超越了我们的预知，我们就必须修改我们的源代码了。这是设计模式所不允许的 ；\n  问题：具体工厂类的创建工作不能满足我们的要求了，创建的工作变化了；\n  解决思路：哪里变化，封装哪里。把具体工厂封装起来。\n  模式好处  ？  模式适合场景   创建对象需要大量重复的代码;\n  创建对象需要访问某些信息，而这些信息不应该包含在复合类中;\n  创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。\n  JDK里的Factory Method模式   Collection中的Iterator方法 ： 对于iterator()方法来说Collection就是一个根抽象工厂，下面还有List等接口作为抽象工厂，再往下有ArrayList等具体工厂\n  JDBC： 在使用JDBC进行数据库开发时，如果数据库由MySQL改为Oracle或其他，则只需要改一下数据库驱动名称就可以，其他都不用修改（前提是使用的都是标准SQL语句）；\n  如果需要设计一个连接邮件服务器的框架，那么就要考虑到连接邮件服务器有几种方式：POP3、SMTP、HTTP。就可以定义一个连接邮件服务器接口，在此接口中定义一些对邮件操作的接口方法，把这三种连接方式封装成产品类，实现接口中定义的抽象方法。再定义抽象工厂和具体工厂，当选择不同的工厂时，对应到产生相应的连接邮件产品对象。采用这种工厂方法模式的设计，就可以做到良好的扩展性。比如某些邮件服务器提供了WebService接口，只需要增加一个产品类和工厂类就可以了，而不需要修改原来代码；\n  Spring框架中的Bean工厂，这是一个复杂对象，所以适合用工厂模式 。\n  UML类图如下 各部分代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14  package cn.ling.factorymethod;\rpublic abstract class Factory {\rpublic final Product create(String owner) {\rProduct p = createProduct(owner) ;\rregisterProduct(p);\rreturn p;\r}\rprotected abstract void registerProduct(Product p);\rprotected abstract Product createProduct(String owner);\r}\r  1 2 3 4 5 6  package cn.ling.factorymethod;\rpublic abstract class Product {\rpublic abstract void use();\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package cn.ling.factorymethod;\rimport java.util.ArrayList;\rimport java.util.List;\rpublic class IDCardFactory extends Factory{\rprivate List owners = new ArrayList();\r@Override\rprotected void registerProduct(Product p) {\rowners.add(((IDCard)p).getOwner()) ;\r}\r@Override\rprotected Product createProduct(String owner) {\rreturn new IDCard(owner) ;\r}\rpublic List getOwners() {\rreturn owners ;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  package cn.ling.factorymethod;\rpublic class IDCard extends Product {\rprivate String owner ;\r//不能为public，这样使得包外的类无法通过new构造出IDCard类的实例；\r //这样就可以强迫外部通过IDCardFactory来生成IDCard的实例\r IDCard (String owner) {\rSystem.out.println(\u0026#34;制作\u0026#34; + owner + \u0026#34;的ID卡\u0026#34;);\rthis.owner = owner ;\r}\r@Override\rpublic void use() {\rSystem.out.println(\u0026#34;使用\u0026#34; + owner + \u0026#34;的ID卡\u0026#34;);\r}\rpublic String getOwner() {\rreturn owner;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13  package cn.ling.factorymethod;\rpublic class Main {\rpublic static void main(String[] args) {\rFactory factory = new IDCardFactory() ;\rProduct card1 = factory.create(\u0026#34;xiaoming\u0026#34;);\rProduct card2 = factory.create(\u0026#34;xiaohong\u0026#34;);\rProduct card3 = factory.create(\u0026#34;xiaogang\u0026#34;);\rcard1.use();\rcard2.use();\rcard3.use();\r}\r}\r  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":27,"section":"posts","tags":["设计模式"],"title":"FactoryMethod模式","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/factory%E6%A8%A1%E5%BC%8F/"},{"content":"数据链路的作用 IP（Internet Protocol）  IP 位于第三层-网络层，主要作用是实现终端节点之间的通信，也叫点对点（end-to-end）通信 三大作用模块：  IP寻址 路由（最终节点为止的转发） IP分包与组包    IP与数据链路  数据链路好比一个个交通中转站，如火车，汽车，飞机，只负责某一个区间之间的通信传输 IP则如行程表，只有出发点和终点，IP负责将数据包发送给最终的目标地址，即点对点通信 只有行程表没有交通工具就无法到达目的地，只有交通工具没有目的地，同样去不了终点。 计算机网络中需要数据链路层和网络层这个分层才能实现向最终目标地址的通信  路由控制（Routing）  发送数据至最终目标地址  HOP（跳）指网络中的一个区间，IP包在网络中的一个个跳间被转发。 路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路都指定出来     路由控制表  所有主机为维护着一张路由控制表（Routing Table）。该表记录IP数据在下一步应该发给哪个路由器。IP包根据该表在各个数据链路上传输    IP分片处理  不同链路之间的MTU不同，有时IP数据包大小比MTU大，所以进行分片处理  IP面向无连接  在发包前，不需要建立与对端目标地址之间的连接，原因如下：  简化：管理每个连接是一件复杂的事 提速：通信前要建立连接会降低处理速度    IP地址  IP地址由网络标志和主机标志两部分组成 IP地址分类：A,B,C,D四类  A类：首位以“0”开头的地址，1~8位是其网络表标识，范围：0.0.0.0~127.0.0.0 B类：前两位为“10”，1~16位为其网络标识，范围：128.0.0.1~191.255.0.0 C类：前三位为“110”，1~24位为其网络标识，范围：192.168.0.0~239.255.255.0 D类：前四位为“1110”，1~32位为其网络标识，范围：224.0.0.0~239.255.255.255（没有主机标识，常用于多播）   IP地址中的主机地址不能全部为0或者全部为1，全部为0表示对应的网络地址或IP地址不可获知的情况下才使用。全部为1的主机地址通常作为广播地址。因此在分配地址时应该去掉这两种情况。  广播地址  广播地址用于在同一个链路中互相连接的主机之间发送数据，主机地址部分全部设置为1就成了广播地址（以太网中MAC地址的所有位都为1时，成为广播地址，因此广播的IP包以数据链路的帧的形式发送时，得通过MAC地址为全1的转发） 广播分为本地广播和直接广播  本地广播：在本网络内的广播叫做本地广播，如网络地址为192.168.0.0/24，广播地址为192.168.0.255.这个广播地址的IP包会被路由器屏蔽，不会传到192.168.0.0/24以外的链路上 直接广播：在不同网络之间广播叫直接广播，如网络地址为192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包，收到这个包的路由器将数据转发给192.168.1.0/24，从而使得网络地址为192.168.1.1~192.168.1.254的主机都能接收到这个包。    IP多播  多播用于将包发送给特定组内的所有主机。广播会将数据发送给所有主机，再由这些主机IP之上的一层去判断是否接收数据，造成不必要的流量，而且广播无法穿透路由。多播则可以穿透路由，还可以实现只给那些必要的组发送数据包。   多播多使用D类地址。IP地址前四位为“1110”,就可以认为是多播地址，剩下的28位可以成为多播的组播号。从224.0.0.0到239.255.255.255都是多播地址的可用范围。其中从224.0.0.0到224.0.0.255的范围不需要路由控制，在同一个链路内也能实现多播。在这个范围之外设置多播地址会给全网所有组内成员发送多播的包（可以利用TTL（生存时间，Time To Live）限制包的到达）。  子网掩码  如何理解子网掩码： https://www.zhihu.com/question/56895036\n   一个IP地址只要确定了分类，也就确定了网络标识和主机标识。网络标识相同的计算机必须同属于同一个链路，B类IP网络理论上允许65000多台计算机连接，然而实际架构中一般不会在同一链路上连接这么多计算机的情况。直接使用A类和B类地址有点浪费，所以需要一种新的组合方式来减少这种浪费。\n  子网掩码也是一个32位的数字，对应IP地址网络标识部分的位全部为\u0026rsquo;1\u0026rsquo;，对应的IP地址主机标识的部分全部为“0”，从而IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由的定位自己的网络标识长度，子网掩码必须是IP地址的首位开始连续的“1”。\n  表示方式：\n 将IP地址与子网掩码的地址分别用两行来表示 后缀法：在每个IP地址后面追加网络地址的位数用“/”隔开如：172.20.100.63 /26    CIDR与VLSM  CIDR: https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1\n  IP地址分类造成A类网址用的很少，C类可允许连接的主机数量只有254，B类地址被大量申请，导致缺乏B类地址缺乏； 因此开始放弃IP地址的分类，采用任意长度分割IP地址的网络标识和主机标识，这种方式叫CIDR（Classless Inter-Domain Routing，无类型域间路由）; CIDR主要是一个按位的、基于前缀的，用于解释IP地址的标准。它通过把多个地址块组合到一个路由表表项而使得路由更加方便。这些地址块叫做CIDR地址块 CIDR是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。  CIDR表示  IPv4的CIDR地址块的表示方法和IPv4地址的表示方法是相似的：由四部分组成的点分十进制地址，后跟一个斜线，最后是范围在0到32之间的一个数字：A.B.C.D/N。点分十进制的部分和IPv4地址一样是一个被分成四个八位位组的32位二进制数，斜线后面的数字就是前缀长度； 因为IPv4地址的长度总是32位，N位长的CIDR前缀就意味着地址里前N位匹配，后{\\displaystyle 32-N}32-N位不匹配。这些位有{\\displaystyle 2^{(32-N)}}2^{{(32-N)}}种不同的组合，即{\\displaystyle 2^{(32-N)}}2^{{(32-N)}}个IPv4地址与CIDR地址块的前缀匹配。前缀越短就能匹配越多的地址，越长就匹配得越少。一个地址可能与多个长度不同的CIDR前缀匹配。  CIDR与子网掩码  子网掩码是一种把前缀编成一种与IP地址相似的形式的掩码。一个子网掩码一共有32位，被分为连续的两部分，高位部分的每一位都被设为二进制的1，其余部分的每一位均被设为二进制的0。其中为1的位的数目和前缀的长度相同。它也被写成点分十进制的形式。子网掩码的作用和前缀一样，但是掩码这种形式出现得比前缀要早； CIDR用可变长子网掩码 （VLSM,Variable Length Subnet Masking），根据各人需要来分配IP地址，而不是按照一个全网络约定的规则。所以，网络/主机的划分可以在地址内的任意位置进行。这个划分可以是递归进行的，即通过增加掩码位数，来使一部分地址被继续分为更小的部分。整个互联网现在都在使用CIDR/VLSM网络地址。除此之外，CIDR也应用在其他方面，尤其是大型私人网络。在普通大小的局域网里则较少应用，因为这些局域网一般使用私有网络。  前缀聚合  CIDR的一个好处在于前缀路由聚合，例如，16个原来的C类（/24）网络现在可以聚合在一起，对外显示了一个/20的网络了（如果这些网络的的地址前20位都相同）。两个对齐的/20网络又可进一步聚合为/19，依此类推。这有效地减少了要对外显示的网络数，防止了路由表爆炸，也遏制了互联网进一步扩大。 通常来说，子网中的第一个地址（主机标识符中的所有二进制零的地址）都保留用于引用网络本身，而最后一个地址用作广播地址用于网络； 这样可以将可用于主机的地址数量减少2个。结果，主机标识符中只有一个二进制数字的/31网络将无法使用，因为这样的子网在减少之后将不提供可用的主机地址。RFC 3021为“全为一的主机”和“全为零的主机”规则创建了一个例外，以使/31网络可用于点对点链接。/31地址（单主机网络）必须通过明确的路由规则访问，因为在这种网络中没有网关的空间。 在大于*/31*或*/32*的路由子网中，可用主机地址的数目通常减少两个，即保留作为广播地址的最大地址和标识网络本身的最小地址。     IP/CIDR Δ 与最后一个地址的差值 掩码 主机数 (*) 类别 备注     a.b.c.d**/32** +0.0.0.0 255.255.255.255 1 1/256 C    a.b.c.d**/31** +0.0.0.1 255.255.255.254 2 1/128 C d = 0 \u0026hellip; (2n) \u0026hellip; 254   a.b.c.d**/30** +0.0.0.3 255.255.255.252 4 1/64 C d = 0 \u0026hellip; (4n) \u0026hellip; 252   a.b.c.d**/29** +0.0.0.7 255.255.255.248 8 1/32 C d = 0 \u0026hellip; (8n) \u0026hellip; 248   a.b.c.d**/28** +0.0.0.15 255.255.255.240 16 1/16 C d = 0 \u0026hellip; (16n) \u0026hellip; 240   a.b.c.d**/27** +0.0.0.31 255.255.255.224 32 1/8 C d = 0 \u0026hellip; (32n) \u0026hellip; 224   a.b.c.d**/26** +0.0.0.63 255.255.255.192 64 1/4 C d = 0, 64, 128, 192   a.b.c.d**/25** +0.0.0.127 255.255.255.128 128 1/2 C d = 0, 128   a.b.c.0**/24** +0.0.0.255 255.255.255.000 256 1 C    a.b.c.0**/23** +0.0.1.255 255.255.254.000 512 2 C c = 0 \u0026hellip; (2n) \u0026hellip; 254   a.b.c.0**/22** +0.0.3.255 255.255.252.000 1,024 4 C c = 0 \u0026hellip; (4n) \u0026hellip; 252   a.b.c.0**/21** +0.0.7.255 255.255.248.000 2,048 8 C c = 0 \u0026hellip; (8n) \u0026hellip; 248   a.b.c.0**/20** +0.0.15.255 255.255.240.000 4,096 16 C c = 0 \u0026hellip; (16n) \u0026hellip; 240   a.b.c.0**/19** +0.0.31.255 255.255.224.000 8,192 32 C c = 0 \u0026hellip; (32n) \u0026hellip; 224   a.b.c.0**/18** +0.0.63.255 255.255.192.000 16,384 64 C c = 0, 64, 128, 192   a.b.c.0**/17** +0.0.127.255 255.255.128.000 32,768 128 C c = 0, 128   a.b.0.0**/16** +0.0.255.255 255.255.000.000 65,536 256 C = 1 B    a.b.0.0**/15** +0.1.255.255 255.254.000.000 131,072 2 B b = 0 \u0026hellip; (2n) \u0026hellip; 254   a.b.0.0**/14** +0.3.255.255 255.252.000.000 262,144 4 B b = 0 \u0026hellip; (4n) \u0026hellip; 252   a.b.0.0**/13** +0.7.255.255 255.248.000.000 524,288 8 B b = 0 \u0026hellip; (8n) \u0026hellip; 248   a.b.0.0**/12** +0.15.255.255 255.240.000.000 1,048,576 16 B b = 0 \u0026hellip; (16n) \u0026hellip; 240   a.b.0.0**/11** +0.31.255.255 255.224.000.000 2,097,152 32 B b = 0 \u0026hellip; (32n) \u0026hellip; 224   a.b.0.0**/10** +0.63.255.255 255.192.000.000 4,194,304 64 B b = 0, 64, 128, 192   a.b.0.0**/9** +0.127.255.255 255.128.000.000 8,388,608 128 B b = 0, 128   a.0.0.0**/8** +0.255.255.255 255.000.000.000 16,777,216 256 B = 1 A    a.0.0.0**/7** +1.255.255.255 254.000.000.000 33,554,432 2 A a = 0 \u0026hellip; (2n) \u0026hellip; 254   a.0.0.0**/6** +3.255.255.255 252.000.000.000 67,108,864 4 A a = 0 \u0026hellip; (4n) \u0026hellip; 252   a.0.0.0**/5** +7.255.255.255 248.000.000.000 134,217,728 8 A a = 0 \u0026hellip; (8n) \u0026hellip; 248   a.0.0.0**/4** +15.255.255.255 240.000.000.000 268,435,456 16 A a = 0 \u0026hellip; (16n) \u0026hellip; 240   a.0.0.0**/3** +31.255.255.255 224.000.000.000 536,870,912 32 A a = 0 \u0026hellip; (32n) \u0026hellip; 224   a.0.0.0**/2** +63.255.255.255 192.000.000.000 1,073,741,824 64 A a = 0, 64, 128, 192   a.0.0.0**/1** +127.255.255.255 128.000.000.000 2,147,483,648 128 A a = 0, 128   0.0.0.0**/0** +255.255.255.255 000.000.000.000 4,294,967,296 256 A     全局地址与私有地址  要是全部IP都要求唯一化，IP地址不足的问题会更加明显，所以出现了私有地址，地址范围如下：  A类：10.0.0.0~10.255.255.255 （10/8） B类：172.16.0.0~172.31.255.255 （172.16/12） C类：192.168.0.0~192.168.255.255（192.168/16）   在这些私有IP地址范围之外的都是全局IP，全局IP基本上要求在整个互联网范围内保持唯一（在使用任播的情况下，多台主机或者路由器可以设置同一个IP），而私有地址只需要在同一个域内保证唯一即可。  路由控制  路由控制表中记录着网络地址与下一步应该发送的路由器的地址。路由器根据IP包的目标地址从控制表中找到与该地址具有相同地址的记录，根据该记录将IP包转发给相应的的下一个路由器。如果路由控制表存在多条相同网络地址的记录，就选择网络地址相同位数最多的，也叫最长匹配； 默认路由：  默认路由是指路由表中任何一个地址都能与之匹配的记录，一般标记为0.0.0.0/0或者default   主机路由：  IP地址/32也被称为主机路由（Host Route），整个IP地址的所有位都参与路由。进行主机路由意味着基于主机上网卡配置的IP地址本身，而不是基于该地址的网络部分进行路由 主机路由多用于不希望通过网络地址路由的情况，但会导致路由表膨大，路由符合增加，进而造成网络性能下降。   环回地址  即localhost(127.0.0.1),用于在同一台计算机上的程序之间进行网络通信，使用这个IP时，数据包不会流向网络   路由控制表的聚合  如将192.168.2.0/24与192.168.3.0/24聚合成192.168.2.0/23    IP分割处理与再构成处理  IP报文的分片（IP Fragmentation）与重组  当IP数据报大于链路MTU时，路由器就会将数据包以8个字节的倍数为单位进行分片处理，最后在目标主机重组分片   路径MTU发现  分片任务对路由器的负担太重，而且还有有分片丢失的风险，所以有了路径MTU发现 路径MTU发现指从发送端到接收端不需要分片时MTU的大小，即路径中存在的所有数据链路中最小的MTU，从而避免了在中途的路由器上进行分片处理 原理（以UDP为例）：  首先在发送端发送IP数据报时将首部的分片禁止标志设置为1，这样途中的路由器即时遇到需要分片才能处理的大包，也不会处理，而是将其丢弃，随后通过ICMP的不可达消息将数据链路上的MTU给发送端 下一次，从发送给同一个目标的IP数据报获得ICMP所通知的MTU值后，将它设置为当前MTU，发送端进行分片处理， 如此反复进行，直到发到接收端前没有再收到ICMP，就认为最后一次ICMP所通知的MTU是合适的MTU 而在TCP的情况下，会根据路径MTU发现计算出最大段MSS，分片处理则交给了TCP层，而IP层不再负责分片      IPv4首部   版本\n IPv4版本号即为4，IPv6版本号为6    首部长度\n 表明IP首部的大小，单位为4字节。对于没有可选项的IP包，则设置为5 ，即IP首部的大小为：4x5=20字节    区分服务\n 表示服务质量    DSCP段与ECN段\n  DSCP（Differential Services Codepoint，差分服务代码点），用于质量控制\n  ECN（Explicit Congestion Notification，显式拥塞通告），用于报告网络拥塞情况，由两个比特构成\n     比特位 简称 含义     6 ECT ECN-Capable Transport   7 CE Congenstion Experienced     第六位的ECT用于通告上层TCP层协议是否处理ECN，当路由器在转发ECN为1的包的过程中，如果出现网络拥塞的情况，则将CE位设置为1.      总长度\n IP首部与数据部分合起来的总字节数。该字段长16比特，所以IP包的最大长度为65535字节    标志\n 用于表示包被分片的相关信息    片偏移\n 用于表示每一个分段相对于原始数据的位置。第一个分片对应的值为0.FO占13位，因此最多可表达8192个相对位置，单位为8字节，因此最大可表示原始数据8x8192=65535个字节的位置    生存时间\n 指可以中转多少个路由器，每经过一个路由器。TTL减1，直到变成0则丢弃该包，经过路由器的个数不会超过256个，因此可以避免IP包在网络内无限传递的问题    协议\n 表示IP首部的下一个首部隶属于哪个协议。    首部校验和\n 指校验数据报的首部，不校验数据部分 用来确保IP数据包不被破坏 首先将该校验和的所有位置设置为0，然后以16比特为单位划分IP首部，并用1补数计算所有16位的和，最后将所得到的和的1补数赋给首部校验和字段    源地址\n 表示发送端IP地址    目标地址\n 表示接收端IP地址    可选项\n 长度可变，通常只用在实验和诊断时使用    填充\n 在有可选项的情况下，首部长度有可能不是32比特的整数倍，通过向字段填充0，调整为32比特的整数倍    IPv6首部格式  IPv6为了减轻路由器的负担，省略了首部校验和字段，因为TCP和UDP在做校验和计算的时候使用伪首部，所以可以验证IP地址或协议是否正确 版本  同IPv4   通信量类  相当于IPv的TOS   流标号  准备用于服务质量控制   有效载荷长度  指包的数据部分，不包括首部   下一个首部  相当于IPv4的协议字段   跳数限制  相当于IPv4的TTL   源地址 目标地址  IPv6扩展首部  IPv6的首部长度固定，无法将可选项加入其中，取而代之的是通过扩展首部对功能有了效扩展。 IPv6扩展首部通常介于IPv6首部与TCP/UDP首部中间 IPv6首部中没有标识以及标识字段，在需要对IP数据报进行分片时，可以使用扩展首部  。\n","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":28,"section":"posts","tags":["图解TCPIP"],"title":"IP","uri":"https://mrxiaoling.github.io/en/posts/%E5%9B%BE%E8%A7%A3tcpip/ip%E5%8D%8F%E8%AE%AE/"},{"content":"仅凭IP无法完成通信  实际使用中很少输入IP，而是直接输入网址 数据链路层也不使用IP地址，在以太网的情况下只使用MAC地址  DNS  IP地址不便记忆，使用更多的是域名 DNS维护的是域名（主机名）和IP地址之间的对应关系  域名的构成  DNS的分层类似于倒挂的树，最顶层的是树的根（Root），第二层是国家域名（cn,jp,uk）和edu，com等特定领域的域名 域名服务器  指管理域名的主机和相应的软件 根域名服务器注册着根以下第一层域名服务器的IP地址；类似的，每一层域名服务器注册着其下一层域名服务器的IP地址   解析器（Resolver）  进行DNS查询的主机和软件叫做DNS解析器    DNS查询  解析器为了查IP地址，首先向域名服务器进行查询，接收这个查询请求的域名服务器首先会在自己的数据库进行查找，如果查到了就返回给客户端，否则则向上一层域名服务器请求查询，以此类推  ARP  ARP以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上就可以通过ARP查找下一跳路由器的MAC地址 ARP只适用于IPv4,IPv6使用ICMPv6代替ARP  ARP工作机制  发送主机会通过广播发送一个ARP请求包，这个包中包含目标主机的IP地址，广播的包可以被同一个链路上所有的主机或路由器结束，如果ARP请求包的目标IP地址与自己IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给发送主机 通常会将获取到的MAC地址缓存到ARP缓存表中一段时间  RARP  Reverse Address Resolution Protocol，是一种从MAC定位IP地址的一种协议  ICMP  Internet Control Message Protocol ， 互联网控制消息协议 主要功能：  确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体的原因，改善网络设置   ICMP的消息类型  通知出错原因的错误消息 用于诊断的查询消息   主要的ICMP消息  ICMP目标不可达消息（类型3） ICMP重定向消息（类型5）  如果路由器发现发送端主机使用了次优的路径发送数据，那么他会返回一个ICMP重定向的消息给主机，在这个消息中包含了最合适的路由信息和源数据   ICMP超时消息（类型11）  IP包中TTL减到0被丢弃时IP路由器将会发送一个ICMP超时的消息，并通知该包已被丢弃   ICMP回送消息（类型0、8）  用于进行通信的主机或者路由器之间，判断所发送的数据包是否成功到达对端的一种消息，包括向对端主机发送回送请求的消息（ICMP Echo Request Message，类型8）和接收端主机发回来的回送应答消息（ICMP Echo Reply Message，类型0），ping命令就是利用这个消息实现的      DHCP  Dynamic Host Configuration Protocol，动态主机设置协议 工作机制  首先需要有DHCP服务器，然后将DHCP所要分配的IP地址设置到服务器上，此外还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上    NAT  Network Address Translator 用于在本地网络中使用私有地址，在连接互联网时转用全局IP地址 例如10.0.0.10的主机与163.221.120.9的主机通信，利用NAT，图中的NAT路由器将发送源地址从10.0.0.10转换为全局IP地址202.244.174.37再发送数据，同理，当包从163.221.120.9发过来时，目标地址202.244.174.37先被转换成私有IP地址10.0.0.10以后再被转发。 NAT路由器内部有一张自动生成的转换地址的表 NAT的潜在问题：  无法从NAT外部向内部服务器建立连接 转换表的生成与转换操作需要一定的开销 通信过程中一旦NAT遇到异常需要重新启动时，所有的TCP连接都会被重置    IP隧道  网络A，B使用IPV6，中间的网络C使用IPv4，网络A和B无法直接进行通信，需要采用IP隧道的功能 IP隧道中可以将从网络A发过来的IPV6的包统合为一个数据，再为之追加一个IPv4的首部转发给网络C 这种在网络层的首部后面继续追加网络层首部的通信方法就叫做IP隧道  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":29,"section":"posts","tags":["图解TCPIP"],"title":"IP协议相关技术","uri":"https://mrxiaoling.github.io/en/posts/%E5%9B%BE%E8%A7%A3tcpip/ip%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"content":"Iterator模式  参考：1.《图解设计模式》\n2. https://blog.csdn.net/Lammonpeter/article/details/82142020 3. JDK里的Iterator模式： https://www.cnblogs.com/tstd/p/5049338.html\n  Iterator模式适用于数据集合中按照顺序遍历集合；  为什么在遍历的时候要额外引入迭代器这种复杂的模式呢？  引入迭代器设计模式的一个重要理由是：将实现和遍历进行了分离，也就是说遍历的过程完全不依赖与你所选择的集合是如何实现的 ， 如果开发者换了其他的容器来承载数据，那么只需要修改集合的实现方式即可，完全不需要去修改遍历的过程代码，这就提高了代码的“可复用性”和“可靠性”。  JDK里的Iterator设计模式 可以看到他们都实现了Iterable接口，Iterable接口的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /**\r* Implementing this interface allows an object to be the target of\r* the \u0026#34;for-each loop\u0026#34; statement. */\rpublic interface Iterable\u0026lt;T\u0026gt; {\r/**\r* Returns an iterator over elements of type {@code T}.\r*\r* @return an Iterator.\r*/\rIterator\u0026lt;T\u0026gt;\rIterator\u0026lt;T\u0026gt; iterator();\rdefault void forEach(Consumer\u0026lt;? super T\u0026gt; action) {\rObjects.requireNonNull(action);\rfor (T t : this) {\raction.accept(t);\r}\r}\rdefault Spliterator\u0026lt;T\u0026gt; spliterator() {\rreturn Spliterators.spliteratorUnknownSize(iterator(), 0);\r}\r}\r  正如JDK注释里说的， 实现iterable接口的类可以使用“foreach”操作，然后并要求实现Iterator iterator()方法，该方法返回一个Iterator接口对象 ，所以使用这些集合时可以直接使用Iterator模式进行遍历\n1 2 3 4  ArrayList\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;();\rarrayList.add(\u0026#34;a\u0026#34;);\rarrayList.add(\u0026#34;a\u0026#34;);\rIterator iterator = arrayList.iterator();\r  示例程序的UML类如下 实例程序代码如下 1 2 3 4 5 6  /**\r* 要遍历的集合的接口，实现该接口的类将成为可以保存多个元素的集合\r*/\rpublic interface Aggregate {\rpublic abstract Iterator iterator();\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class BookShelf implements Aggregate {\rprivate Book [] books ;\rprivate int last = 0;\rpublic BookShelf (int maxsize) {\rthis.books = new Book[maxsize];\r}\rpublic Book getBookAt(int index) {\rreturn books[index];\r}\rpublic void appendBook (Book book) {\rthis.books[last] = book ;\rlast++;\r}\rpublic int getLength() {\rreturn last ;\r}\r@Override\rpublic Iterator iterator() {\rreturn new BookShelfIterator(this);\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /**\r* 用于遍历书架集合里的书\r*/\rpublic class BookShelfIterator implements Iterator {\rprivate BookShelf bookShelf ;\rprivate int index ;\rpublic BookShelfIterator(BookShelf bookShelf) {\rthis.bookShelf = bookShelf ;\rthis.index = 0 ;\r}\r@Override\rpublic boolean hasNext() {\rif (index \u0026lt; bookShelf.getLength()) {\rreturn true;\r} else {\rreturn false;\r}\r}\r@Override\rpublic Object next() {\rBook book = bookShelf.getBookAt(index) ;\rindex ++;\rreturn book;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11  public class Book {\rprivate String name ;\rpublic Book (String name) {\rthis.name = name ;\r}\rpublic String getName() {\rreturn name;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /**\r*测试代码\r*/\rpublic class Main {\rpublic static void main(String[] args) {\rBookShelf bookShelf = new BookShelf(5);\rbookShelf.appendBook(new Book(\u0026#34;图解设计模式\u0026#34;));\rbookShelf.appendBook(new Book(\u0026#34;Java编程思想\u0026#34;));\rbookShelf.appendBook(new Book(\u0026#34;算法\u0026#34;));\rbookShelf.appendBook(new Book(\u0026#34;TCP/IP协议：卷1\u0026#34;));\rIterator iterator = bookShelf.iterator();\rwhile (iterator.hasNext()) {\rBook book = (Book) iterator.next();\rSystem.out.println(book.getName());\r}\r}\r}\r  核心代码  核心代码主要是BookShelfIterator类实现Iterator接口并重写hasNext()和next()方法：hasNext()方法用于检测集合遍历的边界条件，而next()方法则像是遍历指针。  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":30,"section":"posts","tags":["设计模式"],"title":"Iterator模式","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iterator%E6%A8%A1%E5%BC%8F/"},{"content":"运行时数据区  Java8内存模型\nString类和常量池（补充内容）\n几种常量池\nMardword\nString s=new String(\u0026ldquo;abc\u0026rdquo;)创建了2个对象的原因\n   程序计数器\n 可看成是当前线程所执行的字节码的行号指示器； 字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令； 分支，循环，跳转，异常处理，线程恢复都需要依赖它来完成； 如果执行的是本地方法，这个计数器的值为空（undefined）    虚拟机栈\n 虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程； 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）； 这些数据类型在局部变量表中的存储空间以**局部变量槽（Slot）**来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编 译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。    本地方法栈\n 虚拟机栈为执行Java方法（字节码）服务，而本地方法栈为本地方法服务。    Java堆\n Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所 有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存； 根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大 对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间； Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的（通过参数-Xmx和-Xms设定）。    方法区\n 用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据； 虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区 分开来； 与永久代的区别：方法区是JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。    运行时常量池\n 运行时常量池是方法区的一部分； 用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中； 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。    直接内存\n 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。    Java对象 对象的创建  类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞（Bump The Pointer）” 和 “空闲列表（Free List）” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除 （Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。 初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。JVM通过以下两种手段保证线程安全性  CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB（Thread Local Allocation Buffer）： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配   设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 执行 init 方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，\u0026lt;init\u0026gt; 方法（即构造函数）还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 \u0026lt;init\u0026gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。  对象的内存布局  在HotSpot虚拟机里，对象在堆内存的存储布局可划分为三个部分对象头（Header）、实例数据（Instance Data）、和对齐填充（Padding）    对象头包括两类信息：\n  Markword：是用于存储对象自身的运行时数据，如哈 希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效 率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根 据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态 下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年 龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标 记、可偏向）\n   存储内容 lock标志位 状态(lock和biased_lock共同表示对象处于什么锁状态。)     对象hash码、对象分代年龄 01 未锁定）（based_lock = 0）   指向锁记录的指针 00 轻量级锁（based_lock = 1）   指向重量级锁的指针 10 膨胀（重量级锁定）   空，不需要记录信息 11 GC标记   偏向线程ID、偏向时间戳、对象分代年龄 01 可偏向    biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。lock和biased_lock共同表示对象处于什么锁状态。\nage：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。\nidentity_hashcode：31位的对象标识hashCode，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象加锁后（偏向、轻量级、重量级），MarkWord的字节没有足够的空间保存hashCode，因此该值会移动到管程Monitor中。\nthread：持有偏向锁的线程ID。\nepoch：偏向锁的时间戳。\nptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针。\nptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针。\n  类型指针：即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例；如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小。\n    实例数据\n 对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。    对齐填充：\n 不是必须的，仅起占位作用；由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是 任何对象的大小都必须是8字节的整数倍。    对象的访问定位  句柄访问  使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 使用句柄来访问的最大好处就是reference中存储的是稳定句柄地 址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。   指针访问  果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销    String类和常量池\u0026amp;包装类和常量池 1、String对象的两种创建方式 1 2 3  String str1 = \u0026#34;abcd\u0026#34;;\rString str2 = new String(\u0026#34;abcd\u0026#34;);\rSystem.out.println(str1==str2);//false\r   第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。  2、String类的常量池的使用方法  直接使用双引号声明出来的 String 对象会直接存储在常量池中 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。  1 2 3 4 5 6 7  String s1 = new String(\u0026#34;计算机\u0026#34;);\rString s2 = s1.intern();\rString s3 = \u0026#34;计算机\u0026#34;;\rSystem.out.println(s2);//计算机\r //false，因为一个是堆内存中的String对象一个是常量池中的String对象，\r System.out.println(s1 == s2);\rSystem.out.println(s3 == s2);//true，因为两个都是常量池中的String对\r  3、字符串拼接 1 2 3 4 5 6 7 8 9  String str1 = \u0026#34;str\u0026#34;;\rString str2 = \u0026#34;ing\u0026#34;;\rString str3 = \u0026#34;str\u0026#34; + \u0026#34;ing\u0026#34;;//常量池中的对象\rString str4 = str1 + str2; //在堆上创建的新的对象\tString str5 = \u0026#34;string\u0026#34;;//常量池中的对象\rSystem.out.println(str3 == str4);//false\rSystem.out.println(str3 == str5);//true\rSystem.out.println(str4 == str5);//false\r   尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的花，可以使用 StringBuilder 或者 StringBuffer。 总结：  引号\u0026quot;\u0026ldquo;创建的字符用“+”连接生成的对象会在常量池内寻找是否已经创建过的对象； 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中 因此我们提倡用引号包含文本的方式来创建String对象提高效率，实际上这也是我们在编程中常采用的    面试题：String s1 = new String(\u0026ldquo;abc\u0026rdquo;);这句话创建了几个对象？   两个\n  分析：\n 常用的创建一个类的实例（对象）的方法有以下两种:  使用new创建对象 调用Class类的newInstance方法，利用反射机制创建对象   我们正是使用new调用了String类的上面那个构造器方法创建了一个对象，并将它的引用赋值给了str变量。同时我们注意到，被调用的构造器方法接受的参数也是一个String对象，这个对象正是”abc”。 下面的同理  String a=”ab”+”cd”//创建了三个对象\r  8中基本类型的包装类和常量池  ava 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术  1 2 3 4 5 6 7 8 9 10  Integer i1 = 33;\rInteger i2 = 33;\rSystem.out.println(i1 == i2);// 输出true\rInteger i11 = 333;\rInteger i22 = 333;\rSystem.out.println(i11 == i22);// 输出false\rDouble i3 = 1.2;\rDouble i4 = 1.2;\rSystem.out.println(i3 == i4);// 输出false\r\r   Integer 缓存源代码：  /**\r*此方法将始终缓存-128到127（包括端点）范围内的值，并可以缓存此范围之外的其他值。\r*/\rpublic static Integer valueOf(int i) {\rif (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high)\rreturn IntegerCache.cache[i + (-IntegerCache.low)];\rreturn new Integer(i);\r}\r应用场景：\n Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象。  1 2 3  Integer i1 = 40;\rInteger i2 = new Integer(40);\rSystem.out.println(i1==i2);//输出false\r  1 2 3 4 5 6 7 8 9 10 11 12 13  Integer i1 = 40;\rInteger i2 = 40;\rInteger i3 = 0;\rInteger i4 = new Integer(40);\rInteger i5 = new Integer(40);\rInteger i6 = new Integer(0);\rSystem.out.println(\u0026#34;i1=i2 \u0026#34; + (i1 == i2)); //true\r System.out.println(\u0026#34;i1=i2+i3 \u0026#34; + (i1 == i2 + i3)); //true\r System.out.println(\u0026#34;i1=i4 \u0026#34; + (i1 == i4)); //false\r System.out.println(\u0026#34;i4=i5 \u0026#34; + (i4 == i5)); //false\r System.out.println(\u0026#34;i4=i5+i6 \u0026#34; + (i4 == i5 + i6)); // true  System.out.println(\u0026#34;40=i5+i6 \u0026#34; + (40 == i5 + i6)); //true\r  解释：\n语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。\n","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":31,"section":"posts","tags":["JVM"],"title":"java内存区域与内存溢出异常","uri":"https://mrxiaoling.github.io/en/posts/jvm/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"},{"content":"Java基础概念 JDK和JRE的区别？  https://blog.csdn.net/singit/article/details/62040688\n   JDK：java development kit （java开发工具）\n  JRE：java runtime environment （java运行时环境）\n  由图可知JDK包含JRE包含JVM，而且JDK和JRE里都含有JVM\n包装类  https://blog.csdn.net/hebsun/article/details/83533385\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class AutoBoxingTest {\rpublic static void main(String[] args) {\rint i = 100 ;\rInteger i1 = 100 ;\rInteger i2 = 100 ;\r//在值域为[-128,127]之间，用==比较是相等的\r Integer i3 = 200 ;\rInteger i4 = 200 ;\rInteger i5 = new Integer(100);\rInteger i6= new Integer(100);\rSystem.out.println(i1.equals(i));\rSystem.out.println(i1 == i);\rSystem.out.println(i1 == i2);\rSystem.out.println(i1.equals(i2));\rSystem.out.println(i3.equals(i4));\rSystem.out.println(i3 == i4);\rSystem.out.println(i1 == i5);\rSystem.out.println(i5 == i6);\r}\r}\r  输出：\ntrue\rtrue\rtrue\rtrue\rtrue\rfalse\rfalse\rfalse\r原因：这是Integer的静态内部类，在Integer类装入内存中时，会执行其内部类中静态代码块进行其初始化工作，做的主要工作就是把 [-128,127]之间的数包装成Integer类并把其对应的引用存入到cache数组中，这样在方法区中开辟空间存放这些静态Integer变量，同时静态cache数组也存放在这里，供线程享用，这也称静态缓存。我们知道在Java的对象是引用的，所以当用Integer 声明初始化变量时，会先判断所赋值的大小是否在-128到127之间，若在，则利用静态缓存中的空间并且返回对应cache数组中对应引用，存放到运行栈中，而不再重新开辟内存。如此，便导致了上面Integer比较用==比较结果为true的情况发生。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  /**\r* Cache to support the object identity semantics of autoboxing for values between\r* -128 and 127 (inclusive) as required by JLS.\r*\r* The cache is initialized on first usage. The size of the cache\r* may be controlled by the {@code -XX:AutoBoxCacheMax=\u0026lt;size\u0026gt;} option.\r* During VM initialization, java.lang.Integer.IntegerCache.high property\r* may be set and saved in the private system properties in the\r* sun.misc.VM class.\r*/\rprivate static class IntegerCache {\rstatic final int low = -128;\rstatic final int high;\rstatic final Integer cache[];\rstatic {\r// high value may be configured by property\r int h = 127;\rString integerCacheHighPropValue =\rsun.misc.VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;);\rif (integerCacheHighPropValue != null) {\rtry {\rint i = parseInt(integerCacheHighPropValue);\ri = Math.max(i, 127);\r// Maximum array size is Integer.MAX_VALUE\r h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\r} catch( NumberFormatException nfe) {\r// If the property cannot be parsed into an int, ignore it.\r }\r}\rhigh = h;\rcache = new Integer[(high - low) + 1];\rint j = low;\rfor(int k = 0; k \u0026lt; cache.length; k++)\rcache[k] = new Integer(j++);\r// range [-128, 127] must be interned (JLS7 5.1.7)\r assert IntegerCache.high \u0026gt;= 127;\r}\rprivate IntegerCache() {}\r}\r  访问修饰符    修饰符 其他包 同包 子类类 当前类     public 能 能 能 能   protected 不能 能 能 能   default 不能 不能 能 能   private 不能 不能 不能 能    short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1; 有错吗？  https://blog.csdn.net/W_Y_L_/article/details/83056495\n  对于short s1 = 1; s1 = s1 + 1；由于1是int类型，所以s1+1也是int类型，需要强制转换才能赋值给short类型； 对于short s1 = 1; s1 += 1;可以正确编译，s1+=1相当于s1=(short)(s1+1)。 Java语言规范中讲到，复合赋值（E1 op=E2）等价于简单赋值（E1=(T)((E1) op (E2))），其中T是E1的类型，除非E1只被计算一次。\n换句话说，复合赋值表达式自动地将所执行计算的结果转型为其左侧变量的类型。如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响。然而，如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行一个窄化原生类型转换。\n因此，复合赋值表达式可能是危险的。为了避免这种令人不快的突袭，请不要将复合赋值操作符作用于byte、short或char类型的变量。  重载和重写的区别   重载 (Overloading) ：\n 方法重载是让类以统一的方式处理不同类型数据的一种手段， 调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法 ， 重载Overloading是一个类中多态性的一种表现 ； 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时； 无法以返回型别作为重载函数的区分标准 ，因为返回类型不属于方法签名（方法名以及参数类型）的一部分，即不能有两个名字，参数类型相同，返回类型不同的方法； Java允许重载任何方法，包括构造器。    重写 （Overriding）\n 又称方法覆盖； 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。    String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？   可变性：\n 简单的来说：String 类中使用 final 关键字字符数组保存字符串， private final char value[] ，所以 String对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在AbstractStringBuilder中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。    线程安全性：\n String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。    性能：\n 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。\nStringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。    三者的使用总结：\n 操作少量的数据 = String； 单线程操作字符串缓冲区下操作大量数据 = StringBuilder； 多线程操作字符串缓冲区下操作大量数据 = StringBuffer。    ==与equals  ==判断的是两个对象的地址是否相等（基本数据类型比较的是值，引用类型比较的是内存地址） equals（）作用是判断两个对象是否相等，但一般有两个使用情况：  情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”（调用的Object类的房equals方法return (this == obj);）比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相\n等，则返回 true (即，认为这两个对象相等)。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class StringTest {\rpublic static void main(String[] args) {\r//a,b都是引用，且内容一样\r String a = new String(\u0026#34;ab\u0026#34;);\rString b = new String(\u0026#34;ab\u0026#34;);\r//放在常量池中\r String aa = \u0026#34;ab\u0026#34; ;\rString bb = \u0026#34;ab\u0026#34; ;\rSystem.out.println(\u0026#34;a==b:\u0026#34;+ (a==b));\rSystem.out.println(\u0026#34;aa==bb:\u0026#34; + (aa==bb));\rSystem.out.println(\u0026#34;42==42.0:\u0026#34;+ (42==42.0d));\rSystem.out.println(\u0026#34;a.equals(b):\u0026#34;+ (a.equals(b)));\rSystem.out.println(\u0026#34;aa.equals(bb):\u0026#34;+ (aa.equals(bb)));\r}\r}\r  输出：\na==b:false\raa==bb:true\r42==42.0:true\ra.equals(b):true\raa.equals(bb):true\r重写了equals方法，为什么还要重写hashCode方法？  https://cloud.tencent.com/developer/article/1689264\nhttps://www.cnblogs.com/skywang12345/p/3324958.html\n   首先看Object类的hashCode方法注释的的方法约定：\n 如果对象在使用equals方法中进行比较的参数没有修改，那么多次调用一个对象的hashCode()方法返回的哈希值应该是相同的； 如果两个对象通过equals方法比较是相等的，那么要求这两个对象的hashCode方法返回的值也应该是相等的； 如果两个对象通过equals方法比较是不同的，那么也不要求这两个对象的hashCode方法返回的值是不相同的。但是我们应该知道对于不同对象产生不同的哈希值对于哈希表(HashMap等)能够提高性能。    hashcode和equals方法的联系\n  第一类：不使用HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构，那么两者可以说没有关系； 这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。\n  第二类：会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类（比如自定义类作为key）；在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：\n1)、如果两个对象相等，那么它们的hashCode()值一定相同。\n这里的相等是指，通过equals()比较两个对象时返回true。\n2)、如果两个对象hashCode()相等，它们并不一定相等。\n因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。\n 在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  import java.util.*;\rimport java.lang.Comparable;\r/**\r* @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。\r*\r* @author skywang\r* @emai kuiwu-wang@163.com\r*/\rpublic class ConflictHashCodeTest1{\rpublic static void main(String[] args) {\r// 新建Person对象，\r Person p1 = new Person(\u0026#34;eee\u0026#34;, 100);\rPerson p2 = new Person(\u0026#34;eee\u0026#34;, 100);\rPerson p3 = new Person(\u0026#34;aaa\u0026#34;, 200);\r// 新建HashSet对象\r HashSet set = new HashSet();\rset.add(p1);\rset.add(p2);\rset.add(p3);\r// 比较p1 和 p2， 并打印它们的hashCode()\r System.out.printf(\u0026#34;p1.equals(p2) : %s; p1(%d) p2(%d)\\n\u0026#34;, p1.equals(p2), p1.hashCode(), p2.hashCode());\r// 打印set\r System.out.printf(\u0026#34;set:%s\\n\u0026#34;, set);\r}\r/**\r* @desc Person类。\r*/\rprivate static class Person {\rint age;\rString name;\rpublic Person(String name, int age) {\rthis.name = name;\rthis.age = age;\r}\rpublic String toString() {\rreturn \u0026#34;(\u0026#34;+name + \u0026#34;, \u0026#34; +age+\u0026#34;)\u0026#34;;\r}\r/**\r* @desc 覆盖equals方法\r*/\r@Override\rpublic boolean equals(Object obj){\rif(obj == null){\rreturn false;\r}\r//如果是同一个对象返回true，反之返回false\r if(this == obj){\rreturn true;\r}\r//判断是否类型相同\r if(this.getClass() != obj.getClass()){\rreturn false;\r}\rPerson person = (Person)obj;\rreturn name.equals(person.name) \u0026amp;\u0026amp; age==person.age;\r}\r}\r}\r  p1.equals(p2) : true; p1(1169863946) p2(1690552137)\rset:[(eee, 100), (eee, 100), (aaa, 200)]\rPerson的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  import java.util.*;\rimport java.lang.Comparable;\r/**\r* @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。\r*\r* @author skywang\r* @emai kuiwu-wang@163.com\r*/\rpublic class ConflictHashCodeTest2{\rpublic static void main(String[] args) {\r// 新建Person对象，\r Person p1 = new Person(\u0026#34;eee\u0026#34;, 100);\rPerson p2 = new Person(\u0026#34;eee\u0026#34;, 100);\rPerson p3 = new Person(\u0026#34;aaa\u0026#34;, 200);\rPerson p4 = new Person(\u0026#34;EEE\u0026#34;, 100);\r// 新建HashSet对象\r HashSet set = new HashSet();\rset.add(p1);\rset.add(p2);\rset.add(p3);\r// 比较p1 和 p2， 并打印它们的hashCode()\r System.out.printf(\u0026#34;p1.equals(p2) : %s; p1(%d) p2(%d)\\n\u0026#34;, p1.equals(p2), p1.hashCode(), p2.hashCode());\r// 比较p1 和 p4， 并打印它们的hashCode()\r System.out.printf(\u0026#34;p1.equals(p4) : %s; p1(%d) p4(%d)\\n\u0026#34;, p1.equals(p4), p1.hashCode(), p4.hashCode());\r// 打印set\r System.out.printf(\u0026#34;set:%s\\n\u0026#34;, set);\r}\r/**\r* @desc Person类。\r*/\rprivate static class Person {\rint age;\rString name;\rpublic Person(String name, int age) {\rthis.name = name;\rthis.age = age;\r}\rpublic String toString() {\rreturn name + \u0026#34; - \u0026#34; +age;\r}\r/**\r* @desc重写hashCode\r*/\r@Override\rpublic int hashCode(){\rint nameHash = name.toUpperCase().hashCode();\rreturn nameHash ^ age;\r}\r/**\r* @desc 覆盖equals方法\r*/\r@Override\rpublic boolean equals(Object obj){\rif(obj == null){\rreturn false;\r}\r//如果是同一个对象返回true，反之返回false\r if(this == obj){\rreturn true;\r}\r//判断是否类型相同\r if(this.getClass() != obj.getClass()){\rreturn false;\r}\rPerson person = (Person)obj;\rreturn name.equals(person.name) \u0026amp;\u0026amp; age==person.age;\r}\r}\r}\r  p1.equals(p2) : true; p1(68545) p2(68545)\rp1.equals(p4) : false; p1(68545) p4(68545)\rset:[aaa - 200, eee - 100]\r通俗的解释就是：HashMap一类的数据结构首先通过hashcode找到对应的桶，但是不同的对象可能有相同hashcode，即hash冲突，Java里采用链表法，如何确定链表里哪一个是想要找的元素呢，当然是通过equals方法。而对象的哈希码的获取正是通过hashCode方法获取的。如果自定义的类中没有实现该方法，则会采用Object中的hashCode()方法。\n在Object中该方法是一个本地方法，会返回一个int类型的哈希值。可以通过将对象的内部地址转换为整数来实现的，但是Java中没有强制要求通过该方式实现。\n具体实现网络上有不同的说法，有说通过内置地址转换得来，也有说“OpenJDK8默认hashCode的计算方法是通过和当前线程有关的一个随机数+三个确定值，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数”获得。\n无论默认实现是怎样的，大多数情况下都无法满足equals方法相同，同时hashCode结果也相同的条件。比如下面的示例重写与否差距很大。\n    PS：可以通过idea的快速生成重写的equals和hash方法。\nfinal关键字  final关键字主要用在三个地方：变量、方法、类。   对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的\n变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。\n在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的\n任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为fianl。  Object类的常见方法 1 2 3 4 5 6 7 8 9 10 11 12 13  public final native Class\u0026lt;?\u0026gt; getClass()//native方法，用于返回当前运行时对象的Class对象，使用了\rfinal关键字修饰，故不允许子类重写。\rpublic native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的\rHashMap。\rpublic boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。\rprotected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass()== x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。\rpublic String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\rpublic final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\rpublic final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\rpublic final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\rpublic final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\rpublic final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\rprotected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作\r  异常  https://www.cnblogs.com/ljangle/p/10681782.html\n Java的异常类层次结构图如下：\n  Error:\n 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无\n关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止 ; 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（VirtualMachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述.    Exception:\n 异常是发生在程序执行过程中阻碍程序正常执行的错误操作，只要在 Java 语句执行中产生异常则一个异常对象就会被创建 ; 其中 Exception 又被继续划分为被检查的异常（checked exception）和运行时的异常（runtime exception，即不受检查的异常） ; 被检查的异常（Checked exception）在程序中能预期且要尝试修复（如我们必须捕获 FileNotFoundException 异常并为用户提供有用信息和合适日志来进行调试，Exception 是所有被检查的异常的父类）； 运行时异常（Runtime Exception）又称为不受检查异常，譬如我们检索数组元素之前必须确认数组的长度，否则就可能会抛出 ArrayIndexOutOfBoundException 运行时异常，RuntimeException 是所有运行时异常的父类。    java 中 throw 与 throws 的区别是什么？\n  throw语句用在方法体内，表示抛出异常，由方法体内的语句处理 ， 是当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常是，具体向外抛异常的动作，所以它是抛出一个异常实例 ；\n  语句用在方法声明后面，表示抛出异常，由该方法的调用者来处理 ， 主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。\n  throw 使用的位置在方法中，后面跟的异常对象实例，表示抛出异常，由方法体内语句处理，如果方法中有 throw 抛出 RuntimeException 及其子类则声明上可以没有 throws，如果方法中有 throw 抛出 Exception 及其子类则声明上必须有 throws。throws 使用的位置在方法参数小括号后面，后面跟的是一个或者多个异常类名且用逗号隔开，表示抛出异常并交给调用者去处理，如果后面根据的是 RuntimeException 及其子类则该方法可以不用处理，如果后面根据的是 Exception 及其子类则必须要编写代码进行处理或者调用的时候抛出。\n  java异常链？\n https://www.cnblogs.com/darrenqiao/p/9185555.html\n  一 种面向对象的编程技术，将捕获到的异常重新封装到一个新的异常中，并重新抛出。 异常链是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条， 并且希望把异常原始信息保存下来 ，大多用于将受检查异常（checked exception）封装成为非受检查异常（unchecked exception)或者 RuntimeException。特别注意如果你因为一个异常而决定抛出另一个新的异常时一定要包含原有的异常，这样处理程序才可以通过 getCause() 和 initCause() 方法来访问异常最终的根源。 用途： 可以保留每一层的异常信息，用户查看异常的时候，能够从顶层异常信息看到底层异常信息 用法： catch异常之后，将异常作为参数生成一个新的异常并抛出 。    1 2 3 4 5 6 7 8 9 10 11 12  public class ChainedExceptionTest {\rpublic static void main(String[] args) {\rtry {\r//throw original exception\r throw new FileNotFoundException(\u0026#34;oops, no file\u0026#34;);\r} catch (Exception ex) {\r//catch exception and make it into a new exception as member param cause.\r ex.printStackTrace();\rthrow new RuntimeException(ex);\r}\r}\r}\r  输出如下：\njava.io.FileNotFoundException: oops, no file\rat cn.ling.base.ChainedExceptionTest.main(ChainedExceptionTest.java:14)\rException in thread \u0026quot;main\u0026quot; java.lang.RuntimeException: java.io.FileNotFoundException: oops, no file\rat cn.ling.base.ChainedExceptionTest.main(ChainedExceptionTest.java:18)\rCaused by: java.io.FileNotFoundException: oops, no file\rat cn.ling.base.ChainedExceptionTest.main(ChainedExceptionTest.java:14)\rProcess finished with exit code 1\r java 自定义异常   https://blog.csdn.net/weixin_34387284/article/details/93169490\n  什么情况下final块不会执行？   在finally语句块中发生了异常； 在前面的代码中用了System.exit()退出程序； 程序所在的线程死亡； 关闭CPU。  无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句\n时，finally语句块将在方法返回之前被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public class ExceptionTest {\rpublic static void main(String[] args) {\rSystem.out.println(test1());\rSystem.out.println(test2());\r}\r/**\r* 问：请简单描述下面方法的执行流程和最终返回值是多少？\r* @return result\r*/\rpublic static int test1(){\rint ret = 0;\rtry{\rreturn ret;\r}finally{\rret = 2;\r}\r}\rpublic static int test2(){\rint ret = 0;\rtry{\rint a = 5/0;\rreturn ret;\r}finally{\rreturn 2;\r}\r}\r}\r    test1 方法运行返回 0，因为执行到 try 的 return ret; 语句前会先将返回值 ret 保存在一个临时变量中，然后才执行 finally 语句，最后 try 再返回那个临时变量，finally 中对 ret 的修改不会被返回。\n  test2 方法运行返回 2，因为 5/0 会触发 ArithmeticException 异常，但是 finally 中有 return 语句，finally 中 return 不仅会覆盖 try 和 catch 内的返回值且还会掩盖 try 和 catch 内的异常，就像异常没有发生一样（特别注意，当 finally 中没有 return 时该方法运行会抛出 ArithmeticException 异常），所以这个方法就会返回 2，而且不再向上传递异常了\n  1 2 3 4 5 6 7 8  public static void func() {}\rpublic static void main(String args[]) {\rtry{\rfunc();\r}catch(IOException e) {\re.printStackTrace();\r}\r}\r   上面代码段编译时在 IOException 时会出现编译错误，因为 IOException 是受检查异常，而 func 方法并没有抛出 IOException，所以编译报错，但是如果将 IOException 改为 Exception（或者 NullPointerException 等）则编译报错将消失，因为 Exception 可以用来捕捉所有运行时异常，这样就不需要声明抛出语句。  问：关于 java 中的异常处理你有啥心得或者经验？\n答:这其实是一个经验题，答案不局限的，可以自由发挥，下面给出几个示例点。\n 方法返回值尽量不要使用 null（特殊场景除外），这样可以避免很多 NullPointerException 异常。 catch 住了如果真的没必要处理则至少加行打印，这样可在将来方便排查问题。 接口方法抛出的异常尽量保证是运行时异常类型，除非迫不得已才抛出检查类型异常。 避免在 finally 中使用 return 语句或者抛出异常，如果调用的其他代码可能抛出异常则应该捕获异常并进行处理，因为 finally 中 return 不仅会覆盖 try 和 catch 内的返回值且还会掩盖 try 和 catch 内的异常，就像异常没有发生一样（特别注意，当 try-finally 中没有 return 时该方法运行会继续抛出异常）。 尽量不要在 catch 块中压制异常（即什么也不处理直接 return），因为这样以后无论抛出什么异常都会被忽略，以至没有留下任何问题线索，如果在这一层不知道如何处理异常最好将异常重新抛出由上层决定如何处理异常。 方法定义中 throws 后面尽量定义具体的异常列表，不要直接 throws Exception。 捕获异常时尽量捕获具体的异常类型而不要直接捕获其父类，这样容易造成混乱。 避免在 finally 块中抛出异常，不然第一个异常的调用栈会丢失。 不要使用异常控制程序的流程，譬如本应该使用 if 语句进行条件判断的情况下却使用异常处理是非常不好的习惯，会严重影响性能。 不要直接捕获 Throwable 类，因为 Error 是 Throwable 类的子类，当应用抛出 Errors 的时候一般都是不可恢复的情况。  接口和抽象类的区别？  https://github.com/Snailclimb/JavaGuide/issues/146\nhttps://blog.csdn.net/csdnlijingran/article/details/88410948\n  接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法 接口中的实例变量默认是 final 类型的，而抽象类中则不一定 一个类可以实现多个接口，但最多只能实现一个抽象类 一个类实现接口的话要实现接口的所有方法，而抽象类不一定 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。\n备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，必须重写，  Java集合框架 ArrayList 与 Vector 区别？  Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间，Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist； 当存储空间不足的时候，ArrayList默认增加为原来的50%，Vector默认增加为原来的一倍； vector可以设置capacityIncrement，而ArrayList不可以，从字面理解就是capacity容量，Increment增加，容量增长的参数 。  Arraylist 与 LinkedList 异同  线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构：Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构； 插入和删除是否受元素位置的影响：① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素\n位置的影响。 比如：执行add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种\n情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时\n间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）； 是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通\n过元素的序号快速获取元素对象(对应于get(int index) 方法)； 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空\n间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数\n据）。  补充：andomAccess接口\n1 2  public interface RandomAccess {\r}\r   RandomAccess 接口中什么都没有定义，RandomAccess 接口只是一个标志，标识实现这个接口的类具有随机访问功能。  在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用\nindexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法\n1 2 3 4 5 6  public static \u0026lt;T\u0026gt; int binarySearch(List\u0026lt;? extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; list, T key) {\rif (list instanceof RandomAccess || list.size()\u0026lt;BINARYSEARCH_THRESHOLD)\rreturn Collections.indexedBinarySearch(list, key);\relse\rreturn Collections.iteratorBinarySearch(list, key);\r}\r  总结一下 list 的遍历方式选择：\n 实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach； 未实现RandomAccess接口的list， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大\nsize的数据，千万不要使用普通for循环。  一文了解java集合  https://mp.weixin.qq.com/s/COFHO9_BhRbbiMdXMY4dUQ\n hashmap  https://juejin.im/post/6844903554264596487\nhttps://tech.meituan.com/2016/06/24/java-hashmap.html\n ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":32,"section":"posts","tags":["面试"],"title":"Java面试-Java基础概念","uri":"https://mrxiaoling.github.io/en/posts/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"content":"Java多线程基础  https://mp.weixin.qq.com/s?__biz=MzIwNjg4MzY4NA==\u0026amp;mid=2247484552\u0026amp;idx=1\u0026amp;sn=6b0acf6d7501997d5a145db92f78a486\u0026amp;chksm=971b9a83a06c1395addfbfda02ed0ef9790f2a730a39d228119ef5abc2bb0fb4bf1fc42a1190\u0026amp;scene=21#wechat_redirect\n Java中实现多线程有几种方法（每种方法的优缺点？？）  继承Thread类 实现Runnable接口 实现Callable接口通过FutureTask包装器来创建Thread线程； 使用ExecutorService、Callable、Future实现有返回结果的多线程（也就是使用了ExecutorService来管理前面的三种方式）。  如何停止一个正在运行的线程  1）使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 2）使用interrupt方法中断线程  notify()和notifyAll()有什么区别   notify可能会导致死锁，而notifyAll则不会\n任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。\nwait() 应配合while循环使用，不应使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续wait()直至条件满足再往下执行。\nnotify() 是对notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是 WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中。\n  sleep()和wait() 有什么区别？   对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中\n的。\nsleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。\n当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。\n  volatile 是什么?可以保证有序性吗? 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n（1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。\n（2）禁止进行指令重排序。\nvolatile 不是原子性操作\n什么叫保证部分有序性?\n当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n1 2 3 4 5  x = 2;//语句1\ry = 0;//语句2\rflag = true;//语句3\rx = 4;//语句4\ry = -1;//语句5\r  由于ﬂag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。\n使用 Volatile 一般用于 状态标记量 和 单例模式的双检锁\nThread 类中的start() 和 run() 方法有什么区别？  start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。  为什么wait, notify 和 notifyAll这些方法不在thread类里面？  明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。  为什么wait和notify方法要在同步块中调用？ （1）只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。\n（2）如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。\n（3）还有一个原因是为了避免wait和notify之间产生竞态条件。\nwait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。\n在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。\n调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:\u0026ldquo;特殊状态已经被设置\u0026rdquo;。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。\nJava中interrupted 和 isInterruptedd方法的区别？  https://segmentfault.com/a/1190000022039889\nhttps://blog.csdn.net/hj7jay/article/details/53462553 重点学习\n  interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变  Java中synchronized 和 ReentrantLock 有什么不同 相似点：\n这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的。\n区别：\n这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/ﬁnally语句块来完成。\nSynchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。\n由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：\n（1）等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。\n（2）公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。\n（3）锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。\nThread类中的yield方法有什么作用？ Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。\nJava线程池中submit() 和 execute()方法有什么区别？ 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。\n常用的线程池有哪些？ （1）newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n（2）newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。\n（3）newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。\n（4）newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。\n（5）newSingleScheduledThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。\n简述一下你对线程池的理解 （如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。\n（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n（2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n（3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n多个线程轮流打印数字  https://www.cnblogs.com/milton/p/11311148.html\nhttps://zhuanlan.zhihu.com/p/71098723\n ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":33,"section":"posts","tags":["面试"],"title":"Java面试-Java多线程基础","uri":"https://mrxiaoling.github.io/en/posts/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"content":"Mybatis MyBatis中的动态SQL是什么意思？ 对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有：\n if choose / when / otherwise trim where set foreach  MyBatis中命名空间（namespace）的作用是什么？ 在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。\nmybatis对JDBC做了哪些封装？ mybatis的一级和二级缓存  https://blog.csdn.net/u012373815/article/details/47069223\n mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。\nmybaits提供一级缓存，和二级缓存。\n 一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个(内存区域)数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。  一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。\n  二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\n二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。\n  如果缓存中有数据就不用从数据库中获取，大大提高系统性能。\n","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":34,"section":"posts","tags":["面试"],"title":"Java面试-Mybatis","uri":"https://mrxiaoling.github.io/en/posts/%E9%9D%A2%E8%AF%95/spring/mybatis/"},{"content":"Spring基础 什么是spring？   Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。\n  Spring是一个轻量级框架，可以一站式构建你的企业级应用。\nSpring的模块大概分为6个。分别是：\n1、Core Container（Spring的核心）【重要】\n2、AOP（面向切面变成）【重要】\n3、Messaging（消息发送的支持）\n4、Data Access/Integration（数据访问和集成）\n5、Web（主要是SpringWeb内容，包括MVC）【重要】\n6、Test（Spring测试支持，包含JUint等测试单元的支持） 7、Instrumentation（设备支持，比如Tomcat的支持）\n  Spring的优势？   方便解耦，简化开发 ：通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造 成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可 以更专注于上层的应用。\n  AOP编程的支持\n  声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。\n  方便集成各种优秀框架 Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。\n  降低 JavaEE API 的使用难度 Spring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的 使用难度大为降低。\n  Spring中自动装配的方式有哪些  no：不进行自动装配，手动设置Bean的依赖关系。 byName：根据Bean的名字进行自动装配。 byType：根据Bean的类型进行自动装配。 constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。  Spring中Bean的作用域有哪些？ 在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。\n设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。\n单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。\n请问什么是IoC和DI？   控制指的是：当前对象对内部成员的控制权。\n  反转指的是：这种控制权不由当前对象管理了，由其他(类,第三方容器)来管理\n  IOC不够开门见山，于是Martin Fowler提出了DI(dependency injection)来替代IoC，即让调用类对某一接口实现类的依赖关系由第三方(容器或协作类)注入，以移除调用类对某一接口实现类的依赖。\n  两者的区别：\n IoC(思想，设计模式)主要的实现方式有两种：依赖查找，依赖注入。 依赖注入是一种更可取的方式(实现的方式)    使用IOC的好处(知乎@Intopass的回答)：\n  不用自己组装，拿来就用。\n  享受单例的好处，效率高，不浪费空间。\n  便于单元测试，方便切换mock组件。\n  便于进行AOP操作，对于使用者是透明的。\n  统一配置，便于修改。\n    IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的\u0026quot;控制反转\u0026quot;就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - \u0026ldquo;Don’t call me, we will call you\u0026rdquo;。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。\n一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。\n依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供\nSpring中BeanFactory和ApplicationContext的区别是什么？ BeanFactory：\nBeanFactory是spring中比较原始，比较古老的Factory。因为比较古老，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。\nApplicationContext\nApplicationContext是BeanFactory的子类，因为古老的BeanFactory无法满足不断更新的spring的需求，于是ApplicationContext就基本上代替了BeanFactory的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展：\n\u0026lt;1\u0026gt;MessageSource, 提供国际化的消息访问\n\u0026lt;2\u0026gt;资源访问（如URL和文件）\n\u0026lt;3\u0026gt;事件传递\n\u0026lt;4\u0026gt;Bean的自动装配\n\u0026lt;5\u0026gt;各种不同应用层的Context实现\n区别：\n\u0026lt;1\u0026gt;如果使用ApplicationContext，如果配置的bean是singleton，那么不管你有没有或想不想用它，它都会被实例化。好处是可以预先加载，坏处是浪费内存。\n\u0026lt;2\u0026gt;BeanFactory，当使用BeanFactory实例化对象时，配置的bean不会马上被实例化，而是等到你使用该bean的时候（getBean）才会被实例化。好处是节约内存，坏处是速度比较慢。多用于移动设备的开发。\n\u0026lt;3\u0026gt;没有特殊要求的情况下，应该使用ApplicationContext完成。因为BeanFactory能完成的事情，ApplicationContext都能完成，并且提供了更多接近现在开发的功能。\nApplicationContext：只要一读取配置文件，默认情况下就会创建对象。 BeanFactory：什么使用什么时候创建对象。\nspringIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？ • 原理就是通过Java的反射技术来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！\n• 再通过配置文件(xml)或者注解来描述类与类之间的关系\n• 我们就可以通过这些配置信息和反射技术来构建出对应的对象和依赖关系了！\n①IoC（Inversion of Control，控制倒转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。\nIoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。\n举个简单的例子，我们找女朋友常见的情况是，我们到处去看哪里有长得漂亮身材又好的女孩子，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。\n②实现IOC的步骤\n定义用来描述bean的配置的Java类\n解析bean的配置，將bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术\n遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中即可。\n依赖注入的方式有哪几种？以及这些方法如何使用？  https://blog.csdn.net/icarus_wang/article/details/51588284\n 1、Set注入 2、构造器注入 3、接口注入\n@Controller和@RestController的区别是什么？ @RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用\n请谈一下autowired 和resource区别是什么？ 1、共同点\n两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\n2、不同点\n（1）@Autowired\n@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。\n@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。\n（2）@Resource\n@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\nbean的生命周期  https://www.zhihu.com/question/38597960\nhttps://crossoverjie.top/2018/03/21/spring/spring-bean-lifecycle/\n  单例对象：scope=\u0026quot;singleton\u0026rdquo; 一个应用只有一个对象的实例。它的作用范围就是整个引用。 生命周期： 对象出生：当应用加载，创建容器时，对象就被创建了。 对象活着：只要容器在，对象一直活着。 对象死亡：当应用卸载，销毁容器时，对象就被销毁了。 多例对象：scope=\u0026quot;prototype\u0026rdquo; 每次访问对象时，都会重新创建对象实例。 生命周期： 对象出生：当使用对象时，创建新的对象实例。 对象活着：只要对象在使用中，就一直活着。 对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。  作者：MOBIN-F\n链接：https://www.zhihu.com/question/38597960/answer/77600561\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1.Spring对Bean进行实例化（相当于程序中的new Xx()）\n2.Spring将值和Bean的引用注入进Bean对应的属性中\n3.如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()方法\n（实现BeanNameAware清主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的）\n4.如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。\n（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等）\n5.如果Bean实现了ApplicationContextAwaer接口，Spring容器将调用setApplicationContext(ApplicationContext ctx)方法，把y应用上下文作为参数传入.\n(作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory )\n6.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法\n（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）\n7.如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。\n8.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法\n（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )\n9.经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n10.如果Bean实现了DispostbleBean接口，Spring将调用它的destory方法，作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法。\n作者：Young Wang\n链接：https://www.zhihu.com/question/38597960/answer/1063970966\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\na.实例化Bean\n容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。\n 对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。 对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。  实例化对象被包装在BeanWrapper对象中（可以认为是Bean的原生态），BeanWrapper提供了设置对象属性的接口，避免了使用反射机制设置属性。\n这里提到了4个组件：BeanFacotry\\ApplicationContext\\BeanDefinition\\BeanWrapper\nb.设置对象属性（依赖注入）\n实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。\n紧接着，Spring根据BeanDefinition中的信息进行依赖注入。\n并且通过BeanWrapper提供的设置属性的接口完成依赖注入。\nc.注入Aware接口(给bean增加某种能力，申明是某种特殊的bean)\nAware接口用于增强Bean能力\n容器需检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。\n常见的Aware接口有：BeanNameAware\\BeanFactoryAware\\ApplicationContextAware\n至此，一个对象已经被正确构造。\nd.1.BeanPostProcessor(自定义处理，满足用户需求)\n经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。\n该接口提供了两个函数：\n postProcessBeforeInitialzation( Object bean, String beanName )  当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。\n postProcessAfterInitialzation( Object bean, String beanName )  当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在InitialzationBean完成后执行，因此称为后置处理。\n组件：BeanPostProcessor\nd.2.InitializingBean与init-method\n当BeanPostProcessor的前置处理完成后就会进入本阶段。\nInitializingBean接口只有一个函数：\n afterPropertiesSet()  这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。\n若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。\n当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。\ne.DisposableBean和destroy-method\n和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。\nAOP是什么？ AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\nAOP技术恰恰相反，它利用一种称为\u0026quot;横切\u0026quot;的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为\u0026quot;Aspect\u0026rdquo;，即切面。所谓\u0026quot;切面\u0026rdquo;，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。\n使用\u0026quot;横切\u0026quot;技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\nIOC的优点是什么？ IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。\n引入IOC的目的 （1）脱开、降低类之间的耦合；（2）倡导面向接口编程、实施依赖倒换原则； （3）提高系统可插入、可测试、可修改等特性。\n具体做法：（1）将bean之间的依赖关系尽可能地抓换为关联关系；\n（2）将对具体类的关联尽可能地转换为对Java interface的关联，而不是与具体的服务对象相关联；\n（3）Bean实例具体关联相关Java interface的哪个实现类的实例，在配置信息的元数据中描述；\n（4）由IoC组件（或称容器）根据配置信息，实例化具体bean类、将bean之间的依赖关系注入进来。\nSpring框架中的单例Beans是线程安全的么？ Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话**（比如 View Model 对象），就**需要自行保证线程安全**。\nAOP的原理是什么？ AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。通常使用AspectJ的编译时增强实现AOP，AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。\nSpring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。\n如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。\naop的应用场景有哪些？ Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization 同步，Transactions 事务\n持久层设计要考虑的问题有哪些？ 持久层设计的目标包括：\n- 数据存储逻辑的分离，提供抽象化的数据访问接口。\n- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。\n- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。\n- 数据抽象，提供更面向对象的数据操作。\n如何理解切点，切面这些概念  https://www.zhihu.com/question/344440064\n 三层架构   表现层：\n 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）    业务层：\n 也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业 务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制）    持久层：\n  也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进 行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库 中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。\n  MVC模型 MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：\n  Model（模型）： 通常指的就是我们的数据模型。作用一般情况下用于封装数据。\n  View（视图）： 通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。 通常视图是依据模型数据创建的\n  Controller（控制器）： 是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。 它相对于前两个不是很好理解，这里举个例子： 例如： 我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。 这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充 到模型之中。 此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做 的。 当校验失败后，由控制器负责把错误页面展示给使用者。 如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。\n  SpringMVC的异常处理 系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息， 后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的 dao、service、controller 出现都通过 throws Exception 向上抛出，最后由 springmvc 前端 控制器交由异常处理器进行异常处理，如下图：\n具体步骤：\n1、自定义异常类\n1 2 3 4 5 6 7 8 9 10  public class CustomException extends Exception {\rprivate String message;\rpublic CustomException(String message) {\rthis.message = message;\r}\rpublic String getMessage() {\rreturn message;\r}\r}\r  2、自定义异常处理器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class CustomExceptionResolver implements HandlerExceptionResolver {\r@Override\rpublic ModelAndView resolveException(HttpServletRequest request,\rHttpServletResponse response, Object handler, Exception ex) {\rex.printStackTrace();\rCustomException customException = null;\r//如果抛出的是系统自定义异常则直接转换\rif(ex instanceof CustomException){\rcustomException = (CustomException)ex;\r}else{\r//如果抛出的不是系统自定义异常则重新构造一个系统错误异常。\rcustomException = new CustomException(\u0026#34;系统错误，请与系统管理 员联系！\u0026#34;);\r}\rModelAndView modelAndView = new ModelAndView();\rmodelAndView.addObject(\u0026#34;message\u0026#34;, customException.getMessage());\rmodelAndView.setViewName(\u0026#34;error\u0026#34;);\rreturn modelAndView;\r}\r}\r  3、 配置异常处理器\n1 2 3  \u0026lt;!-- 配置自定义异常处理器 --\u0026gt;\r\u0026lt;bean id=\u0026#34;handlerExceptionResolver\u0026#34;\rclass=\u0026#34;com.itheima.exception.CustomExceptionResolver\u0026#34;/\u0026gt;\r  SpringMVC拦截器   Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 用户可以自己定义一些拦截器来实现特定的功能。 谈到拦截器，还要向大家提一个词——拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺 序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。\n  和过滤器的区别：\n 过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦 截的。    1、编写一个普通类实现 HandlerInterceptor 接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class HandlerInterceptorDemo1 implements HandlerInterceptor {\r@Override\rpublic boolean preHandle(HttpServletRequest request, HttpServletResponse\rresponse, Object handler)\rthrows Exception {\rSystem.out.println(\u0026#34;preHandle 拦截器拦截了\u0026#34;);\rreturn true;\r}\r@Override\rpublic void postHandle(HttpServletRequest request, HttpServletResponse response,\rObject handler,\rModelAndView modelAndView) throws Exception {\rSystem.out.println(\u0026#34;postHandle 方法执行了\u0026#34;);\r}\r@Override\rpublic void afterCompletion(HttpServletRequest request, HttpServletResponse\rresponse, Object handler, Exception ex)\rthrows Exception {\rSystem.out.println(\u0026#34;afterCompletion 方法执行了\u0026#34;);\r}\r  2、配置拦截器\n1 2 3 4 5 6 7 8  \u0026lt;!-- 配置拦截器 --\u0026gt;\r\u0026lt;mvc:interceptors\u0026gt;\r\u0026lt;mvc:interceptor\u0026gt;\r\u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt;\r\u0026lt;bean id=\u0026#34;handlerInterceptorDemo1\u0026#34;\rclass=\u0026#34;com.itheima.web.interceptor.HandlerInterceptorDemo1\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;\r\u0026lt;/mvc:interceptor\u0026gt;\r\u0026lt;/mvc:interceptors\u0026gt;\r  SpringMVC执行流程 ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":35,"section":"posts","tags":["面试"],"title":"Java面试-Spring","uri":"https://mrxiaoling.github.io/en/posts/%E9%9D%A2%E8%AF%95/spring/spring/"},{"content":"Java多线程 线程和进程的概念  进程  在现代大多数面向线程设计的系统，进程是线程的容器。（在分时系统中，进程称为“用户程序”或者“任务”）   线程  是操作系统能够进行运算调度的最小单位，被包含于进程之中。 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。    线程安全的概念  线程安全：  指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成，得到预期的结果    什么是CAS   CAS（compare and swap）的缩写\n  CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（汇编指令）指令。\n  利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成 的。\n  整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升\n  CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它 线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试。\n  缺点：\n  ABA问题\n  循环时间长开销大  自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。    只能保证一个共享变量的原子操作  CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。       1、使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤\n2、synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞 争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线 程冲突严重的情况下，性能远⾼于CAS。\n 悲观锁和乐观锁  面试必备之乐观锁与悲观锁\n   悲观锁\n 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 一般多写的场景下用悲观锁就比较合适    乐观锁\n 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。    什么是AQS 从ReentrantLock的实现看AQS的原理及应用\n原子操作以及原子类 1、原⼦操作是指⼀个不受其他操作影响的操作任务单元。原⼦操作是在多线程环境下避免数据不⼀致必须的⼿段。\n2、为了解决这个问题，必须保证增加操作是原⼦的，在JDK1.5之前我们可以使⽤同步技术来做到这⼀点。 到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类（比如AtomicInteger，AtomicLong），它们可以⾃动的保证对于他们的操作是原⼦的并 且不需要使⽤同步。\n什么是Executors框架 Java通过Executors提供四种线程池，分别为：\n1、newCachedThreadPool创建⼀个可缓存线程池，如果线程池⻓度超过处理需要，可灵活回收空闲线程，若⽆可 回收，则新建线程。\n2、newFixedThreadPool 创建⼀个定⻓线程池，可控制线程最⼤并发数，超出的线程会在队列中等待。\n3、newScheduledThreadPool 创建⼀个定⻓线程池，⽀持定时及周期性任务执⾏。\n4、newSingleThreadExecutor 创建⼀个单线程化的线程池，它只会⽤唯⼀的⼯作线程来执⾏任务，保证所有任务 按照指定顺序(FIFO, LIFO, 优先级)执⾏。\nJava中的阻塞队列 1、JDK7提供了7个阻塞队列。（也属于并发容器）\ni. ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。\nii. LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。\niii. PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。\niv. DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。\nv. SynchronousQueue：⼀个不存储元素的阻塞队列。\nvi. LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。 vii. LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。\n","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":36,"section":"posts","tags":["面试"],"title":"Java面试-多线程","uri":"https://mrxiaoling.github.io/en/posts/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"content":"Prototype模式  参考：1.《图解设计模式》\nhttps://www.cnblogs.com/xuekyo/archive/2012/07/12/2587730.html\njava的浅克隆和深克隆：https://www.cnblogs.com/betterboyz/p/9356190.html\nSpring中的原型模式： https://www.jianshu.com/p/611be5eb42a1\n 模式定义  创建对象的种类，并且通过拷贝这些原型创建新的对象; Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节。 例如仪器数据采集器的共同初始化工作可在原型类对象中完成，随后将其克隆出PDF文件数据采集器对象和Excel文件数据采集器对象，并为两对象属性做后续的扩展，免去了公共属性的初始化工作。  模式原理  通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。  解决何种问题  让父类控制子类方法的调用顺序 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  模式好处  每次NEW一个对象，都需要执行一次构造函数，如果构造函数时间长，那么多次执行初始化的效率大大降低了。一般在初始化信息不变化的情况下，克隆是最好的方法。这既隐藏了对象创造的细节，又对性能是大大的提升。  模式适合场景  对象种类繁多，无法将其整合到一个类中，如果要这些对象分别作为一个类，则需要编写很多类文件； 生成实例的过程太复杂，难以根据类来生成实例； 想要让生成实例的框架依赖具体的类，这时不能指定类名来生成实例，而是事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。  Spring里的Prototype模式   原型bean的创建\n\r\rbean\r\r 创建原型bean需要特别声明  1  \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;com.zlx.demo.Hello\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  protected \u0026lt;T\u0026gt; T doGetBean(\rfinal String name, final Class\u0026lt;T\u0026gt; requiredType, final Object[] args, boolean typeCheckOnly)\rthrows BeansException {\rfinal String beanName = transformedBeanName(name);\rObject bean;\r// Eagerly check singleton cache for manually registered singletons.\r Object sharedInstance = getSingleton(beanName);\rif (sharedInstance != null \u0026amp;\u0026amp; args == null) {\r...\r}\relse {\r...\rtry {\r...\r// Create bean instance.\r if (mbd.isSingleton()) {\r...\r}\r//创建原型bean\r else if (mbd.isPrototype()) {\r// It\u0026#39;s a prototype -\u0026gt; create a new instance.\r Object prototypeInstance = null;\rtry {\rbeforePrototypeCreation(beanName);\rprototypeInstance = createBean(beanName, mbd, args);\r}\rfinally {\rafterPrototypeCreation(beanName);\r}\rbean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\r}\relse {\r...\r}\r}\rcatch (BeansException ex) {\rcleanupAfterBeanCreationFailure(beanName);\rthrow ex;\r}\r}\r...\rreturn (T) bean;\r}\r  \r\r   UML类图如下 各部分代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package cn.ling.prototype;\rimport java.util.HashMap;\r/**\r* @Author:ling\r* @Date:2020/4/30 21:08\r* @Version:1.0\r*/\rpublic class Manager {\rprivate HashMap showCase = new HashMap();\rpublic void register (String name , Product proto) {\rshowCase.put(name, proto) ;\r}\rpublic Product create (String protoname) {\rProduct product = (Product) showCase.get(protoname);\rreturn product.createClone();\r}\r}\r  1 2 3 4 5 6 7  package cn.ling.prototype;\rpublic interface Product extends Cloneable{\rpublic abstract void use(String s) ;\rpublic abstract Product createClone() ;\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package cn.ling.prototype;\r/**\r* @Author:ling\r* @Date:2020/4/30 21:12\r* @Version:1.0\r*/\rpublic class MessageBox implements Product {\rprivate char decochar;\rpublic MessageBox (char decochar) {\rthis.decochar = decochar ;\r}\r@Override\rpublic void use(String s) {\rint length = s.getBytes().length;\rfor (int i = 0 ; i \u0026lt; length + 4 ; i++) {\rSystem.out.print(decochar);\r}\rSystem.out.println(\u0026#34;\u0026#34;);\rSystem.out.println(decochar + \u0026#34;\u0026#34; + s + \u0026#34;\u0026#34; + decochar);\rfor (int i = 0 ; i \u0026lt; length + 4 ; i++){\rSystem.out.print(decochar);\r}\rSystem.out.println(\u0026#34;\u0026#34;);\r}\r@Override\rpublic Product createClone() {\rProduct p = null ;\rtry {\rp = (Product) clone();\r} catch (CloneNotSupportedException e) {\re.printStackTrace();\r}\rreturn p;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  package cn.ling.prototype;\r/**\r* @Author:ling\r* @Date:2020/4/30 21:20\r* @Version:1.0\r*/\rpublic class UnderlinePen implements Product {\rprivate char ulchar ;\rpublic UnderlinePen (char ulchar) {\rthis.ulchar = ulchar;\r}\r@Override\rpublic void use(String s) {\rint length = s.getBytes().length;\rSystem.out.println(\u0026#34;\\\u0026#34;\u0026#34; + s + \u0026#34;\\\u0026#34;\u0026#34;);\rSystem.out.println(\u0026#34; \u0026#34;);\rfor (int i = 0 ; i \u0026lt; length + 4 ; i++) {\rSystem.out.print(ulchar);\r}\rSystem.out.println(\u0026#34;\u0026#34;);\r}\r@Override\rpublic Product createClone() {\rProduct p = null ;\rtry {\rp = (Product) clone();\r} catch (CloneNotSupportedException e) {\re.printStackTrace();\r}\rreturn p;\r}\r}\r  package cn.ling.prototype;\r/**\r* @Author:ling\r* @Date:2020/4/30 21:30\r* @Version:1.0\r*/\rpublic class Main {\rpublic static void main(String[] args) {\rManager manager = new Manager();\rUnderlinePen underlinePen = new UnderlinePen('~') ;\rMessageBox mbox = new MessageBox('*') ;\rMessageBox sbox = new MessageBox('/') ;\rmanager.register(\u0026quot;Strong message\u0026quot;, underlinePen);\rmanager.register(\u0026quot;warning box\u0026quot;, mbox);\rmanager.register(\u0026quot;slash box\u0026quot;, sbox);\rProduct p1 = manager.create(\u0026quot;Strong message\u0026quot;) ;\rp1.use(\u0026quot;Hello world\u0026quot;);\rProduct p2 = manager.create(\u0026quot;warning box\u0026quot;);\rp2.use(\u0026quot;Hello world\u0026quot;);\rProduct p3 = manager.create(\u0026quot;slash box\u0026quot;);\rp3.use(\u0026quot;Hello world\u0026quot;);\r}\r}\rJava的克隆方法  Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份 Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。  克隆需满足的条件 clone()方法将对象复制了一份并返还给调用者。所谓“复制”的含义与clone()方法是怎么实现的。一般而言，clone()方法满足以下的描述：\n　（1）对任何的对象x，都有：x.clone()!=x。换言之，克隆对象与原对象不是同一个对象。\n　（2）对任何的对象x，都有：x.clone().getClass() == x.getClass()，换言之，克隆对象与原对象的类型一样。\n　（3）如果对象x的equals()方法定义其恰当的话，那么x.clone().equals(x)应当成立的。\n　在JAVA语言的API中，凡是提供了clone()方法的类，都满足上面的这些条件。JAVA语言的设计师在设计自己的clone()方法时，也应当遵守着三个条件。一般来说，上面的三个条件中的前两个是必需的，而第三个是可选的。\n浅克隆和深克隆 -无论你是自己实现克隆方法，还是采用Java提供的克隆方法，都存在一个浅度克隆和深度克隆的问题。\n 浅度克隆  　只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。\n 深度克隆  　除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。\n　深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。\n利用序列化实现深度克隆  把对象写到流里的过程是序列化(Serialization)过程；而把对象从流中读出来的过程则叫反序列化(Deserialization)过程。应当指出的是，写到流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。 在Java语言里深度克隆一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的拷贝）写到一个流里（序列化），再从流里读回来（反序列化），便可以重建对象。 这样做的前提就是对象以及对象内部所有引用到的对象都是可序列化的，否则，就需要仔细考察那些不可序列化的对象可否设成transient，从而将之排除在复制过程之外。 浅度克隆显然比深度克隆更容易实现，因为Java语言的所有类都会继承一个clone()方法，而这个clone()方法所做的正式浅度克隆。有一些对象，比如线程(Thread)对象或Socket对象，是不能简单复制或共享的。不管是使用浅度克隆还是深度克隆，只要涉及这样的间接对象，就必须把间接对象设成transient而不予复制；或者由程序自行创建出相当的同种对象，权且当做复制件使用。  模式总结  在上述代码中，Product接口和Manager类中代码中完全没有出现MessageBox类和UnderlinePen类的名字，这意味着我们可以独立修改Product和Manager，不受MessageBox类和UnderlinePen类的影响，一旦在类中使用了别的类名，就意味着该类与其他类紧密的耦合在了一起。  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":37,"section":"posts","tags":["设计模式"],"title":"Prototype模式","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/prototype%E6%A8%A1%E5%BC%8F-/"},{"content":"计算机网络概述  参考：《TCP/IP详解 卷1：协议》\nB站UP：湖科大教书匠 https://space.bilibili.com/360996402/\nOSI体系结构： https://blog.csdn.net/taotongning/article/details/81352985\nhttps://blog.csdn.net/qq_37954088/article/details/80171093\n 网络数据交互方法   三种交换方式：\n 电路交换 分组交换 报文交换    电路交换的 3 个步骤\n 建立连接（分配通信资源） 通话（一直占用通信资源） 释放连接（归还通信资源）   分组交换\n将待发送的资源分解成一定字节数的数字信息“块”独立通过网络，来自不同的块可以组合，而且以后可以分解，这被称为多路复用。  三种方式的对比  电路交换优点      优点 缺点     分组交换 1. 无需建立连接； 2. 线路利用率高； 3. 简化了存储管理； 4. 加速传输； 5. 减少出错率 1. 引起了转发时延； 2. 需要传输额外的信息，例如源地址，目的地址； 3. 对于数据报存在失序，丢失或重复分组的问题；对于虚电路服务，存在呼叫建立，数据传输和虚电路释放三个过程   电路交换 1. 时延小 ；2.有序传输 ；3. 无冲突； 4. 适用范围广； 5. 实用性强； 6. 控制简单 1. 建立连接时间长；2. 线路独占，使用效率低；3. 灵活性差； 4. 难以规格化   报文交换 1. 无需建立连接； 2. 动态分配线路； 3. 提高线路可靠性； 4. 提高线路利用率； 5. 提供多目标服务 1. 引起了转发时延； 2. 需要较大的存储空间； 3. 需要传输额外的信息。    网络的性能指标 带宽  用来表示网络的通信线路所能传送数据的能力，即单位时间内从网络中的某一点到另一点的最高速率，单位：b/s,kb/s,Mb/s,Gb/s,Tb/s。  速率 比特：计算机中数据量的单位，也是信息论中数据量的单位。一个比特就是二进制中的一个“0”或一个“1”，常见换算：\n 8bit = 1 Byte KB = 2^10B\nMB = K·KB=2^10·2^10B=2^20B\nGB=K·MB = 2^30B\nTB = K·GB = 2^40B  速率：连接在计算机网络的主机在传送比特的速率，也称为比特速率或数据率。\n  bit/s (b/s , bps)\nkb/s = 10^3 b/s\nMb/s = 10^3·10^3b/s\n  吞吐量  单位时间内通过某个网络（信道，接口）的数据量。  时延 网络时延=发送时延+传播时延+ 处理时延\n 发送时延：分组长度(b)/发送速率(b/s) 传播时延：信道长度(m)/电磁波传播速率(m/s) 处理时延：不容易计算  时延带宽积  时延带宽积 = 传播时延*带宽 又称以比特为单位的链路长度  往返时间（Round-Trip Time）  双向交互一次所需要的的时间  利用率  利用率包括信道利用率和网络利用率 信道利用率：表示信道有百分之几的时间是有数据通过的； 网络利用率： 全网络的信道利用率的加权平均  利用率并非越高越好——————根据排队论，该信息引起的时延会迅速增加\r丢包率  即分组丢失率，指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率 分组丢失的两种主要情况：   分组在传输过程中出现误码，被结点丢弃； 分组在到达另一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞。  计算机网络体系结构分层 TCP/IP体系结构   TCP/IP体系结构的五层分别为：应用层、传输层、网络层、数据链路层、物理层\n  其中物理层可以归为硬件技术，数据链路层，网络层和传输层可以归为系统层，而应用层可以归为用户层。\n物理层\r数据链路层\r网络层\r传输层\r应用层\r总结\r\r 字面意思解释：物理传输、硬件、物理特性。狭义意思可以是光缆、电缆、双绞线和无线电波这些传输介质、物理接口，中间传的是电信号或光信号 \r\r 标志网络中的各主机（主机编码问题，例如MAC地址） 从信号所表示的一串比特流中区分出地址和数据 协调各主机争用总线\n \r\r 标志各网络以及网络中的各主机（网络和主机共同编址的问题，例如IP地址） 路由器如何转发分组，如何进行路由选择\n \r\r  传输层是负责在会话进程之间建和维护端——端连接的，实现网络环境中分布式通信。\n  解决进程之间基于网络的通信问题\n  出现传输错误时，如何处理\n  \r 通过应用进程间的交互来完成特定的网络应用\n \r\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"41ff45eac6c30962\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r\n  OSI体系结构  OSI体系结构的七层分别为：应用层、传输层、网络层、数据链路层、会话层、表示层、物理层  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":38,"section":"posts","tags":["网络协议"],"title":"redis","uri":"https://mrxiaoling.github.io/en/posts/redis/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"content":"Singleton模式  参考：1.《图解设计模式》\n五种单例模式： https://segmentfault.com/a/1190000018000917\n单例模式概念： https://blog.csdn.net/hb_csu/article/details/80504276\nJDK中的单例模式： https://blog.csdn.net/wobushixiaobailian/article/details/86744763\n静态内部类加载时间： https://www.cnblogs.com/zouxiangzhongyan/p/10762540.html\n反射以及反序列化攻击： https://www.cnblogs.com/happy4java/p/11206105.html\n枚举怎么保证线程安全： https://blog.csdn.net/ncuzengxiebo/article/details/80754107\n 模式定义  在软件系统运行过程中，某个类只存在一个实例 : 一个类实现单例模式时需要具备以下3个条件： 类的内部定义一个该类的静态私有成员变量； 构造方法为私有； 提供静态工厂方法，供外部获取类的实例；  模式优点 解决何种问题  保证一个类只有一个实例，并且提供一个访问该实例的全局访问入口  模式好处  由于单例模式只生成一个实例 ，减少了系统给的性能开销，当一个对象需要产生时，当时消耗的资源较多。那么产生对象时构建的方式就可以通过单例去构建 ； 单例模式存在全局访问点，所以可以优化共享资源访问。  模式实例  Windows的任务管理器 Windows的回收站，也是一个单例应用 项目中的读取配置文件的对象 数据库的连接池 Servlet中的Application Servlet SpringMVC Struts中的控制器 Spring中的Bean默认也是单例的  模式使用场景  需要频繁实例化然后销毁的对象 ； 创建对象时耗时过多或者耗资源过多，但又经常用到的对象 ； 有状态的工具类对象 ； 频繁访问数据库或文件的对象 ；  JDK里的Template Method模式   java.lang.Runtime\n  java.text. NumberFormat\n\r\rRuntime\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /**\r* Every Java application has a single instance of class\r*/\rpublic class Runtime {\rprivate static Runtime currentRuntime = new Runtime();\r/**\r* Returns the runtime object associated with the current Java application.\r* Most of the methods of class \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; are instance\r* methods and must be invoked with respect to the current runtime object.\r*\r* @return the \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; object associated with the current\r* Java application.\r*/\rpublic static Runtime getRuntime() {\rreturn currentRuntime;\r}\r/** Don\u0026#39;t let anyone else instantiate this class */\rprivate Runtime() {}\r....\r}\r  \r\r   各部分代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package cn.ling.singleton;\r/**\r* 饿汉式：线程安全，调用效率高，但是不能延时加载\r* 缺点:系统加载时消耗额外资源，如果该实例没有使用的情况会造成资源浪费\r*/\rpublic class Singleton1 {\r//在类加载式自行实例化对象,线程安全的,因为类只加载一次\r //类初始化时，立即加载这个对象\r private static Singleton1 instance = new Singleton1();\r//构造器私有 无法创建对象\r private Singleton1() {\r}\r//对外提供get方法获取 该类的实例\r public static Singleton1 getInstance() {\rreturn instance;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package cn.ling.singleton;\r/**\r* 懒汉式，线程不安全\r*/\rpublic class Singleton2 {\rprivate static Singleton2 instance = null ;\rprivate Singleton2 () {\r}\r//调用时加载对象\r //下面这段代码 不是原子性操作 会出现线程安全问题\r //如果想要线程安全，可加上synchronized关键字，但是这样效率低下\r public /**synchronized*/static Singleton2 getInstance() {\rif (instance == null) {\rinstance = new Singleton2();\r}\rreturn instance;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package cn.ling.singleton;\r/**\r* 懒汉式（双重同步锁）\r*/\rpublic class Singleton3 {\rpublic static volatile Singleton3 instance = null ;\rprivate Singleton3() {\r}\r/**\r* 解决了性能问题，来自JVM的指令重排序\r* 解决：在对象中添加volatile 关键字来 不让jvm对该 对象做优化\r* @return\r*/\rpublic static Singleton3 getInstance() {\rif (instance == null) {\rsynchronized (Singleton3.class) {\rif (instance == null) {\rinstance = new Singleton3();\r}\r}\r}\rreturn instance;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package cn.ling.singleton;\r/**\r* 静态内部类\r* 静态内部类式和饿汉式一样，同样利用了ClassLoader的机制保证了线程安全\r* 同的是，饿汉式在Singleton类被加载时就创建了一个实例对象，\r* 而静态内部类即使Singleton类被加载也不会创建单例对象，\r* 除非调用里面的getInstance()方法。因为当Singleton类被加载时\r* 其静态内部类SingletonHolder没有被主动使用。只有当调用getInstance方法时，\r* 才会装载SingletonHolder类，从而实例化单例对象。\r* 这样，通过静态内部类的方法就实现了lazy loading，很好地将懒汉式和饿汉式结合起来，\r* 既实现延迟加载，保证系统性能，也能保证线程安全\r*/\rpublic class Singleton4 {\rprivate static class SingleInnerHolder {\rprivate static Singleton4 instance = new Singleton4();\r}\rprivate Singleton4() {\r}\rpublic static Singleton4 getInstance() {\rreturn SingleInnerHolder.instance;\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  package cn.ling.singleton;\r/**\r* @Author:ling\r* @Date:2020/4/23 13:19\r* @Version:1.0\r* 枚举单例\r*/\rpublic enum Singleton5 {\r//实例化对象\r INSTANCE ;\rvoid getInstance() {\r}\r}\r  模式总结  懒汉式效率最低； 占用资源少 不需要延时加载 枚举优于 饿汉式 ； 占用资源比较多 需要延时加载 静态内部类 优于 懒汉式 。  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":39,"section":"posts","tags":["设计模式"],"title":"Singleton模式","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/singleton%E6%A8%A1%E5%BC%8F/"},{"content":"传输层  如果说网络层（IP）比作收货地址，那么传输层（TCP\u0026amp;UDP）决定收货人（接收的应用程序），为了实现这一功能，使用了端口号来识别应用程序。 TCP是面向连接的，可靠的流（流指不间断的数据结构）协议。TCP为了实现可靠传输，实现“顺序控制”或“重发控制”机制，此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等功能； UDP是不可靠的数据包协议。虽然可以确保发送消息的大小，但是不能保证消息一定会到达，如果需要重发处理，则该操作交由程序完成。 操作系统使用TCP或者UDP进行通信时，又会广泛使用套接字（socket）的API，套接字由两组IP：port组成。  端口号  链路层和网络层中的地址叫MAC地址和IP地址，前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。 传输层也有这种类似地址的概念，就是端口号，用来识别同一台计算机中进行通信的不同程序，因此也被程序地址。  通过IP地址、端口号、协议号进行通信识别  TCP/IP或者UDP/IP 通常采用“源地址IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”，只要有一项不同，则被认为是其他通信。  端口号如何确定  标准既定的端口号（静态方法）  自行指定端口号，但是要避开知名端口号以及注册端口号   时序分配法（动态方法）  程序无需设置端口号，完全交由操作系统，动态分配的端口号取值范围在49152到65535之间。    端口号与协议  端口号由其使用的传输层协议决定，所以不同的传输协议可以使用相同的端口号  UDP  UDP，User Datagram Protocol UDP 通常用于以下几个方面：  包总量较少的通信（DNS，SNMP等） 视频，音频等多媒体通信（即时通信） 限定于LAN等特定网络中应用程序中的应用通信 广播通信（广播，多播）    TCP 超时重发如何确定  重发超时指在重发数据前，等待确认应答到来的那个特定时间间隔，如果超过了这个时间仍未收到确认应答，发送端将进行数据重发； 这个时间会随着网络环境不断变化，而TCP要求无论在何种环境下都需要提供高性能通信，为此TCP在每次发包时都会计算往返时间及其偏差，将这个往返时间和偏差相加重发超时的时间就能确保“确认应答一定能在这个时间内返回”  连接管理\u0026mdash;三次握手，四次挥手  TCP在数据通信之前，通过TCP首部发送SYN包作为建立连接的请求等待确认应答，如上图，一个连接的建立和断开，正常至少需要来回发送7个包才能完成 建立连接  客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数A。  服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。 最后，客户端再发送一个ACK。此时包的序号被设定为A+1，而ACK的确认码则为B+1。当服务端收到这个ACK的时候，就完成了三次握手，并进入了连接创建状态。     如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为。\n  断开连接   在这个过程中连接的每一侧都独立地被终止。当一个端点要停止它这一侧的连接，就向对侧发送FIN，对侧回复ACK表示确认。因此，拆掉一侧的连接过程需要一对FIN和ACK，分别由两侧端点发出。\n  首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793定义了MSL为2分钟，Linux设置成了30s。参数tcp_max_tw_buckets控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的TIME_WAIT状态的连接给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow）\n  连接可以工作在TCP半开状态。即一侧关闭了连接，不再发送数据；但另一侧没有关闭连接，仍可以发送数据。已关闭的一侧仍然应接收数据，直至对侧也关闭了连接。\n也可以通过测三次握手关闭连接。主机A发出FIN，主机B回复FIN \u0026amp; ACK，然后主机A回复ACK\n 为什么要三次握手 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是 双方确认自己与对方的发送与接收是正常的。\n1、客户端–发送带有 SYN 标志的数据包–一次握手–服务端\n2、 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端\n3、客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端\n  第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。\n  第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发 送正常\n  第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常， 对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。\n  为什么要传回 SYN 接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先 发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表 示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据 才可以在客户机和服务器之间传递。\n  为什么要四次挥手\n  任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送 的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的 话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道 了”，这样通话才算结束。\n  TCP以段为单位发送数据  在建立TCP连接的同时，可以确认发送数据包的单位MSS（Maximum Segment Size,最大消息长度），最理想的情况是正好是IP中不会被分片处理的最大数据长度。TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。 在三次握手时，会在TCP首部写入MSS选项，然后在两者之间选择一个较小的值投入使用  利用窗口控制提高速度  每发一个段数据包进行一次确认应答的处理的缺点：包的往返时间越长通信性能越低 为了解决这个问题引入了窗口这个概念，发送端在发送了一个段后不必一直等待确认应答，而是继续发送 窗口大小：  指无需等待确认应答而可以继续发送数据的最大值，    窗口控制与重发控制  确认应答未能返回的情况：  这种情况下数据已经到达对端，是不需要重发的     某个报文段丢失的情况：  当某个报文段丢失后，发送端会一直收到接收端发送的同一个确认应答，当连续三次收到同一个确认应答就会将对应的数据进行重发，这就是TCP的高速重发控制    流控制  在一些高负荷的情况下，接收端将本应该接收的数据丢弃的话，又会重发重发机制，从而导致网络流量的浪费 因此TCP提供了一种可以让发送端根据接收端的实际接收能力控制发送的数据量的机制，即流控制，具体操作是接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就是窗口大小，由接收端主机决定。  拥塞控制   TCP的窗口控制使得可以连续发送大量数据包，但是如果在通信刚开始时就发送大量数据会引发一些问题，甚至会导致整个网络的瘫痪\n  TCP为了防止该问题，在通信一开始时就会通过一个叫慢启动算法得的数值对发送数据量进行控制\n  为了量化发送端调节的数据的量，定义了一个叫“拥塞窗口”的概念，在慢启动的时候把拥塞窗口的大小设置为1个数据段（1MSS），之后每收到一次确认应答，拥塞窗口的值就+1，在发送前还要与接收端通知的窗口大小做比较，选择较小者\n  随着包的每次往返，拥塞窗口的值以1、2、4等指数函数的增长，从而导致网络拥塞的发生，为了防止这种情况的发生，引入了慢启动阈值的概念，只要拥塞窗口的值超出这个阈值，在每收到一次确认应答时，只允许以下面的比例放大拥塞窗口：\n​\t（1个数据段的字节数*1个数据段字节数）/拥塞窗口（字节）\n  TCP通信刚开始时，并没与设置相应的慢启动阈值，而是在超时重发时才会设置为当时拥塞窗口一半的大小\n  而由重复确认应答进行高速重发控制时，慢启动阈值的大小被设置为“实际已发送但未收到确认应答的数据量”的一半，然后将窗口的大小设置为该慢启动阈值+3个数据段的大小。\n  提高网络利用率的规范  Nagle算法 延迟确认应答  收到数据后不立即返回确认应答，而是延迟一段时间 由于TCP采用滑动窗口的控制机制，在TCP文件传输中大多数是每两个数据段返回一次确认应答。   捎带应答  UDP首部格式  校验和： https://blog.csdn.net/yaoxingshuai/article/details/51063546\nhttps://seanwangjs.github.io/2017/10/19/udp-protocol-checksum.html\n\u0026ldquo;二进制反码求和\u0026rdquo; 等价于 \u0026ldquo;二进制求和再取反\u0026rdquo; ？？？？ https://blog.csdn.net/limanjihe/article/details/85270291\n  校验和  UDP校验和使用的是UDP伪首部，这是由于TCP/IP 识别一个进行通信的应用的五要素：“源地址IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”，但是UDP首部只包含源端口和目标端口，剩下的三项在IP首部，如果其他三项被破坏，就会导致收包的应用收不到包 检验和计算步骤：  把检验和字段置为0 其次，对整个首部中的每个16 bit进行二进制反码求和 将计算得到的补码和写入校验和字段      实例：\nIP头：\n​ 45 00 0031\n​ 89 F5 0000\n​ 6E 06 0000（校验字段）\n​ DE B7 455D -\u0026gt; 222.183.69.93\n​ C0 A8 00DC -\u0026gt; 192.168.0.220\n计算：\n4500+ 0031 +89F5 + 0000 + 6e06+ 0000 + DEB7 + 455D + C0A8 + 00DC =322C4\n0003+ 22C4 = 22C7\n~22C7 =DD38 -\u0026gt;即为应填充的校验和\n当接受到IP数据包时，要检查IP头是否正确，则对IP头进行检验，方法同上：\n计算：\n4500 + 0031+89F5 + 0000 + 6E06+ DD38 + DEB7 + 455D + C0A8 + 00DC =3 FFFC\n0003 + FFFC= FFFF\n~FFFF =00000 -\u0026gt;正确\nTCP首部格式  序列号  字段长32位，指发送数据的位置，每发一次数据，就累加一次该数据字节数的大小 序列号不是从0或1开始，而是将一个随机数作为初始值，然后通过SYN包传给接收端主机   确认应答号  字段长32位，指下一次应该收到的数据的序列号   数据偏移  字段长32位（长4位，单位为4字节），表示TCP传输的数据部分应该从TCP包的哪个位开始计算，可看作是TCP首部的长度   保留  为了以后拓展使用，长度4位，一般设置为0   控制位  长度为8位，从左至右分别为：CWR、ECE、URG、ACK、PSH、RST、SYN、FIN CWR（Congestion Window Reduced）  与后面的ECE都用于IP首部的ECN字段，为1时则通知对方已将拥塞窗口缩小   ECE（ECN-Echo）  为1时表示会通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部的ECE设置为1   URG（Urgent Flag）  为1时表示包中有需要紧急处理的数据，并在后面的紧急指针中再进行解释   ACK（Acknowledgement Flag）  为1时，确认应答的字段变为有效。TCP规定除了最初建立连接的SYN包之外该位必须设置为1   PSH（Push Flag）  为1时表示需要将收到的数据立刻传给上层应用协议；为0时不需要立即传而是先进行缓存   RST（Reset Flag）  为1时表示TCP连接中出现异常必须强制断开连接   SYN（Synchronize Flag）  用于建立连接，为1时表示希望建立连接，并在其序号的字段进行序号的初始值设定   FIN（Fin Flag）  为1时表示今后不会再有数据发送，希望断开连接     窗口大小（window size）  字段长16位，用于通知从相同TCP首部的确认应答号所指位置开始能接收的数据大小（8字节）；如果窗口为0，则表示可以发送窗口探测，但是这个数据必须是1个字节   紧急指针（Urgent Pointer）  字段长16位，只有在URG控制位为1时有效。从数据部分的首位到紧急指针所指示的位置为止为紧急数据   选项（Options）  用于提高TCP的传输性能，长度最大为40字节 常见选项类型：  类型2:MSS 类型3：窗口扩大，用于改进TCP吞吐量的选项 类型8：时间戳，当数据量非常大时，32位序列号可能迅速用完，所以引入这个选项，区分新老时间戳 类型4和5：用于选择性应答（Selective ACKnowledgement）,TCP 的应答一般只有一个数字，数据段在时不时丢失的情况下，接收方收到的数据段的序号不连续，呈有一个每一个的“豁牙子状态”，有了这个选项就可以允许最大4次的“豁牙子状态”确认应答，这样既可以避免无用重发的同时，还可以提高重发的速度，进而提高网络的吞吐量      窗口大小与吞吐量  TCP通信的最大吞吐量由窗口大小和往返时间决定，设最大吞吐量为Tmax,窗口大小为W，则Tmax=W/RTT 设窗口为65535字节，RTT为0.1秒，则Tmax=5242800（bps）=5.2(Mbps) 上面的公式表明1个TCP连接所能传输的最大吞吐量为5.2Mbps  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":40,"section":"posts","tags":["图解TCPIP"],"title":"TCP\u0026UDP","uri":"https://mrxiaoling.github.io/en/posts/%E5%9B%BE%E8%A7%A3tcpip/tcpudp/"},{"content":"TemplateMethod模式  参考：1.《图解设计模式》\nhttps://cloud.tencent.com/developer/article/1609361\nhttps://www.jianshu.com/p/800a44c1d9dd\nhttps://www.cnblogs.com/jing99/p/12607905.html\n 模式定义  定义一个操作算法中的框架，而将这些步骤延迟加载到子类中； 其本质就是固定算法框架或者说算法每个部分的执行顺序  解决何种问题  让父类控制子类方法的调用顺序 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  模式好处  开发人员在开发时，只需要考虑方法的实现。不需要考虑方法在何种情况下被调用。实现代码复用。  模式适合场景   一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。\n  各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。\n  需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。\n  JDK里的Template Method模式   java.io.InputStream 、 java.io.OutputStream 、 java.io.Reader 以及java.io.Writer中所有非抽象方法\n  java.util.AbstractList, java.util.AbstractSet以及java.util.AbstractMap中所有非抽象方法。\n\r\rInputStream\r\r 上面的非抽象方法给定了从输入流中读取数据的具体流程，而如何从输入流中读取，却没有给出具体的实现方法，需要java.io.InputStream这个抽象类的子类来具体实现read方法。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public int read(byte b[], int off, int len) throws IOException {\rif (b == null) {\rthrow new NullPointerException();\r} else if (off \u0026lt; 0 || len \u0026lt; 0 || len \u0026gt; b.length - off) {\rthrow new IndexOutOfBoundsException();\r} else if (len == 0) {\rreturn 0;\r}\rint c = read();\rif (c == -1) {\rreturn -1;\r}\rb[off] = (byte)c;\rint i = 1;\rtry {\rfor (; i \u0026lt; len ; i++) {\rc = read();\rif (c == -1) {\rbreak;\r}\rb[off + i] = (byte)c;\r}\r} catch (IOException ee) {\r}\rreturn i;\r}\rpublic abstract int read() throws IOException;\r  \r\r   UML类图如下 各部分代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package cn.ling.TemplateMethod;\rpublic abstract class Game {\r/**\r* 初始化游戏\r*/\rpublic abstract void initialize();\r/**\r* 开始游戏\r*/\rpublic abstract void startPlay();\r/**\r* 结束游戏\r*/\rpublic abstract void endPlay();\r/**\r* 模板方法：确定了游戏的流程\r*/\rpublic final void playGame() {\rinitialize();\rstartPlay();\rendPlay();\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package cn.ling.TemplateMethod;\rpublic class BasketBallGame extends Game {\r@Override\rpublic void initialize() {\rSystem.out.println(\u0026#34;Basketball Game Initialized! Start playing.\u0026#34;);\r}\r@Override\rpublic void startPlay() {\rSystem.out.println(\u0026#34;Basketball Game Started. Enjoy the game!\u0026#34;);\r}\r@Override\rpublic void endPlay() {\rSystem.out.println(\u0026#34;Basketball Game Finished!\u0026#34;);\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  package cn.ling.TemplateMethod;\rpublic class FootBallGame extends Game {\r@Override\rpublic void initialize() {\rSystem.out.println(\u0026#34;Football Game Initialized! Start playing.\u0026#34;);\r}\r@Override\rpublic void startPlay() {\rSystem.out.println(\u0026#34;Football Game Started. Enjoy the game!\u0026#34;);\r}\r@Override\rpublic void endPlay() {\rSystem.out.println(\u0026#34;Football Game Finished!\u0026#34;);\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package cn.ling.TemplateMethod;\r/**\r* 测试代码\r*/\rpublic class Main {\rpublic static void main(String[] args) {\rGame basketBallGame = new BasketBallGame();\rGame footBallGame = new FootBallGame();\rbasketBallGame.playGame();\rSystem.out.println();\rfootBallGame.playGame();\r}\r}\r  模式总结   模板方法模式有两个角色：抽象类和具体子类\n  AblstractClass（抽象类）：在抽象类中定义了一系列的操作PrimitiveOperation，每个操作可以使具体的，也可以是抽象的，每个操作对应一个算法的步骤，在子类中可以重新定义或实现这些步骤。TmplateMethod()这个方法用于定义一个算法结构，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。\n  ConcreteClass（具体子类）：用于实现在父类中声明的抽象基本操作，也可以覆盖在父类中已经实现的具体基本操作。\n  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":41,"section":"posts","tags":["设计模式"],"title":"TemplateMethod模式","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/templatemethod%E6%A8%A1%E5%BC%8F/"},{"content":"Nginx 安装以及配置  参考链接： https://blog.csdn.net/stinkstone/article/details/78082748\n Centos7\rWindows\r\r1、 官网下载安装包 http://nginx.org/en/download.html 可以选择浏览器下载或者通过 wget 命令下载\n1 2  cd /usr/local\rwget http://nginx.org/download/nginx-1.16.1.tar.gz\r  2、 安装 Nginx 首先安装 Nginx 依赖库\n1 2 3 4 5 6 7  yum install gcc-c++\ryum install pcre\ryum install pcre-devel\ryum install zlib\ryum install zlib-devel\ryum install openssl\ryum install openssl-devel\r  解压安装包\n1  tar -zxvf nginx-1.16.1.tar.gz\r  执行安装，nginx 会默认安装到/usr/local/nginx 目录\n1 2  cd /usr/local/nginx-1.16.1.tar.gz\r./configure #执行./configure\r  如果执行成功，执行 make 和 make install 编译 Nginx\n1 2  make\rmake install\r  3、配置 Nginx 开机启动 1 2  cd /lib/systemd/system/\rvim nginx.service #创建nginx.service文件\r  文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  [Unit]\rDescription=nginx\r After=network.target\r [Service]\rType=forking\r ExecStart=/usr/local/nginx/sbin/nginx\r ExecReload=/usr/local/nginx/sbin/nginx reload\r ExecStop=/usr/local/nginx/sbin/nginx quit\r PrivateTmp=true\r [Install]\rWantedBy=multi-user.target\r   执行 systemctl enable nginx.service 使 nginx 开机启动\n1  systemctl enable nginx.service\r  4、相关命令 1 2 3 4 5  systemctl start nginx.service #启动nginx\rsystemctl stop nginx.service #结束nginx\rsystemctl restart nginx.service #重启nginx\r  5、验证是否安装成功 输入http://服务器IP/ 如果能看到 nginx 的界面，就表示安装成功了，如果是本地机器访问，执行输入 localhost 即可\n6、Nginx 静态资源配置  切换到/usr/local/nginx/conf 目录，并打开 nginx.conf 文件  1 2  cd /usr/local/nginx/conf\rvi nginx.conf\r  \r1、下载安装包 http://nginx.org/en/download.html下载相应版本的windows安装包，解压到自己的文件夹下\n2、启动 Nginx 有很多种方法启动 nginx\n  直接双击 nginx.exe，双击后一个黑色的弹窗一闪而过\n  打开 cmd 命令窗口，切换到 nginx 解压目录下，输入命令 nginx.exe 或者 start nginx ，回车即可。\n  3、验证是否安装成功  输入http://服务器IP/ 如果能看到 nginx 的界面，就表示安装成功了，如果是本地机器访问，执行输入 localhost 即可。  4、Nginx 配置以及静态资源部署  进入 conf 文件，编辑 nginx.conf 文件\n 找到以下这段代码：\n 部署静态资源时直接将其复制到部署文件下即可，下面是我的博客静态资源\n  \r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"0d751410100e3590\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":42,"section":"posts","tags":["开发环境配置"],"title":"各种开发环境配置合集","uri":"https://mrxiaoling.github.io/en/posts/%E5%90%84%E7%A7%8D%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%9B%86%E5%90%88/"},{"content":"数据链路的作用  数据链路指参考模型的数据链路层，有时也指以太网，无线局域网等手段。  数据链路相关技术  MAC地址（ Media Access Control Address ）  媒体访问控制地址，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的地址（识别数据链路中互连的节点）。     共享介质型网络  共享介质型网络有两种介质访问控制方式：  争用方式  也叫CSMA（ Carrier Sense Multiple Access ，载波监听多路访问） 在一部分以太网中采用的是CSMA/CD方式（ Carrier Sense Multiple Access with Collision Detection ，载波侦听多路访问／碰撞检测）  如果载波信道上没有信道流动，则任何栈都可以发送数据 检查是否会发生冲突，一旦发生冲突，立即放弃发送数据，同时立即释放载波信道 放弃发送后，随机延时一段时间，在重新争用介质，重新发送帧     令牌传递方式  沿着令牌环发送叫做“令牌”的特殊报文，只有获得令牌额站才能发送数据 特点：  不会有冲突 每个站都有通过平等循环获得令牌的机会         非共享介质网络  一般采用双全工通信方式 通过以太网交换机构建网络，从而使计算机与交换机端口之间形成一对一的连接，即可实现双全工通信，不会发生冲突   根据ＭＡＣ地址转发  以太网有多个端口，根据每个帧的目标MAC地址决定从哪个网络接口发送数据，依靠**转发表（Forwarding Table）**实现 交换机自学原理  数据链路层的每个通过点在连接到包时，会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中     环路检测技术  生成树方式  每个网桥必须在每1~10秒内相互交互BPDU（Bridge Protocol Data Unit）包，从而判断哪些端口不适用，以便消除环路 缺点是发生故障到切换网络需要几十秒，所以可用RSTP（Rapid Spanning Tree Protocol），可缩短至几秒内   源路由法   VLAN\n 如上图，交换机按照端口区分了多个网段，从而区分了广播数据传播的范围，减少了网络负载并提高了网络的安全性，两个网段则需要通过三层交换机（如路由）进行通信    以太网（Ethernet） 以太网帧格式  以太网前端有个前导码（Preamble）的部分，表示一个以太网帧的考试，也是对端网卡能够确保与其同步的标志，前导码末尾是一个叫做“SFD（Start Frame Delimiter）”的域，值是“11”，在这个域后是以太网帧的本体 本体前端后面是以太网的首部，共占14个字节   FCS（Frame Check Sequence，帧检验序列），用于检测帧是否有损坏  PPP  PPP（Point-to-Point Protocol，点对点协议） PPP主要功能包括两个协议：  不依赖上层的LCP协议（Link Control Protocol）  负责建立和断开连接，设置最大接收单元（MRU Maximum Receive Unit），设置验证协议（PAP或CHAP）以及设置是否进行通信质量的监控   依赖上层的NCP协议（Netwotrk Control Protocol），如果上层为IP，此时IPCP（IP Control Protocol）  IPCP负责IP地址设置以及是否进行TCP/IP首部压缩       通过PPP连接时，通常需要进行用户名密码的验证，并对通信双端进行双方向的验证（但一般对ISP不验证）。主要协议有两种：  PAP（Password Authentication Protocol）  密码以明文传输，安全性较弱   CHAP（Challenge Handshake Authentication Protocol）  使用一次性密码（One Time Password），可访窃听且会进行定期的密码交换，用来检验对端是否中途被替换。     PPP的帧格式  PPP是基于HDLC（High Level Data Link Control Procedure,高级数据链路控制）制定出来的一种协议 在每个帧的前后加上一个8位字节的标志码“01111110”用来区分帧， 在两个标志码中间不允许出现连续6个一个的“1”，当出现连续5个1时后面必须插入一个“0”     PPPoE  以太网没有验证功能，也没有建立和断开连接的处理，所以采用PPPoE(PPPoE over Ethernet)    ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":43,"section":"posts","tags":["图解TCPIP"],"title":"数据链路","uri":"https://mrxiaoling.github.io/en/posts/%E5%9B%BE%E8%A7%A3tcpip/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/"},{"content":"计算机网络概述  参考：《TCP/IP详解 卷1：协议》\nB站UP：湖科大教书匠 https://space.bilibili.com/360996402/\n 物理层概念  物理层解决的是各种传输媒体上传输比特0和1的问题，进而给链路层提供透明传输比特流的服务（所谓“透明”，是指链路层看不见，也无需看见物理层使用的什么方法进行比特传输的，只需享受物理层提供的比特流传输服务即可）  物理层协议的主要任务  机械特性： 指明接口所用接线器的形状和尺寸，引导数目和排列、固定和锁定装置； 电气特性： 指明在接口电缆的各条线上出现的电压范围； 功能特性： 某条线上出现的某一电平的电压表示何种意义； 过程特性： 指明对于不同功能的各种可能事件的出现特性。  物理层下的传输媒体  导引型传输媒体： 同轴电缆、双绞线、光纤和电力线； 非导引型传输媒体： 无线电波、微波、红外线和可见光。  传输方式  串行传输与并行传输： 网络传输一般用串行传输，在计算机内部一般用并行，比如多核CPU与总线 同步传输与异步传输 单向通信（单工）、双向交替通信（半双工）和双向同时通信（双工）  同步传输与异步传输  同步传输：  手法双方时钟同步方法：  外同步： 在双方之间添加一条单独的时钟信号线； 内同步： 发送端将时钟同步信号编码到发送数据中一起传输，如曼彻斯特编码。     异步传输  字节之间异步（字节之间的时间间隔不固定） 字节中的每个比特任然要同步（各比特的持续时间是相同的）    编码调制  码元：  在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形    常用编码 调制方法  基本调制与混合调制  混合调制举例-正交振幅调制QAM    信道的极限容量  信号失真问题：  奈氏准则  奈氏准则：  在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的； 在理想低通道的最高码元传输速率=2W Baud = 2W 码元/秒；（W： 信道带宽（Hz） Baud： 波特，即码元/秒） 理想带通信道的最高码元传输速率 = W Baud = W 码元/秒； 波特率与比特率的关系：  当一个码元只携带1比特的信息量时，两者在数值上是相等的； 当一个码元携带n比特的信息量时，则波特率转换成比特率时，数值要乘以n   要提高传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量，这需要采用多元制   香农公式：  带宽受限且有高斯白噪声干扰的信道的极限信息传输速率；    $$\nc=W\\times \\log_{2}(\\frac SN + 1)\n$$\nc: 信道的极限信息传输速率（b/s）\nW： 信道带宽（Hz）\nS： 信道内所传信号的平均功率\nN： 信道内的高斯噪声功率\nS/N: 信噪比，使用分贝（dB）作单位\n$$\nS/N=10 \\times \\log_{10}\\frac SN (dB)\n$$\n 根据公式，要想提高传输速率，必须提高信道中的信噪比  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":44,"section":"posts","tags":["网络协议"],"title":"物理层协议","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/"},{"content":"计算机网络概述  参考：《TCP/IP详解 卷1：协议》\nB站UP：湖科大教书匠 https://space.bilibili.com/360996402/\nOSI体系结构： https://blog.csdn.net/taotongning/article/details/81352985\nhttps://blog.csdn.net/qq_37954088/article/details/80171093\n 网络数据交互方法   三种交换方式：\n 电路交换 分组交换 报文交换    电路交换的 3 个步骤\n 建立连接（分配通信资源） 通话（一直占用通信资源） 释放连接（归还通信资源）   分组交换\n将待发送的资源分解成一定字节数的数字信息“块”独立通过网络，来自不同的块可以组合，而且以后可以分解，这被称为多路复用。  三种方式的对比  电路交换优点      优点 缺点     分组交换 1. 无需建立连接； 2. 线路利用率高； 3. 简化了存储管理； 4. 加速传输； 5. 减少出错率 1. 引起了转发时延； 2. 需要传输额外的信息，例如源地址，目的地址； 3. 对于数据报存在失序，丢失或重复分组的问题；对于虚电路服务，存在呼叫建立，数据传输和虚电路释放三个过程   电路交换 1. 时延小 ；2.有序传输 ；3. 无冲突； 4. 适用范围广； 5. 实用性强； 6. 控制简单 1. 建立连接时间长；2. 线路独占，使用效率低；3. 灵活性差； 4. 难以规格化   报文交换 1. 无需建立连接； 2. 动态分配线路； 3. 提高线路可靠性； 4. 提高线路利用率； 5. 提供多目标服务 1. 引起了转发时延； 2. 需要较大的存储空间； 3. 需要传输额外的信息。    网络的性能指标 带宽  用来表示网络的通信线路所能传送数据的能力，即单位时间内从网络中的某一点到另一点的最高速率，单位：b/s,kb/s,Mb/s,Gb/s,Tb/s。  速率 比特：计算机中数据量的单位，也是信息论中数据量的单位。一个比特就是二进制中的一个“0”或一个“1”，常见换算：\n 8bit = 1 Byte KB = 2^10B\nMB = K·KB=2^10·2^10B=2^20B\nGB=K·MB = 2^30B\nTB = K·GB = 2^40B  速率：连接在计算机网络的主机在传送比特的速率，也称为比特速率或数据率。\n  bit/s (b/s , bps)\nkb/s = 10^3 b/s\nMb/s = 10^3·10^3b/s\n  吞吐量  单位时间内通过某个网络（信道，接口）的数据量。  时延 网络时延=发送时延+传播时延+ 处理时延\n 发送时延：分组长度(b)/发送速率(b/s) 传播时延：信道长度(m)/电磁波传播速率(m/s) 处理时延：不容易计算  时延带宽积  时延带宽积 = 传播时延*带宽 又称以比特为单位的链路长度  往返时间（Round-Trip Time）  双向交互一次所需要的的时间  利用率  利用率包括信道利用率和网络利用率 信道利用率：表示信道有百分之几的时间是有数据通过的； 网络利用率： 全网络的信道利用率的加权平均  利用率并非越高越好——————根据排队论，该信息引起的时延会迅速增加\r丢包率  即分组丢失率，指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率 分组丢失的两种主要情况：   分组在传输过程中出现误码，被结点丢弃； 分组在到达另一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞。  计算机网络体系结构分层 TCP/IP体系结构   TCP/IP体系结构的五层分别为：应用层、传输层、网络层、数据链路层、物理层\n  其中物理层可以归为硬件技术，数据链路层，网络层和传输层可以归为系统层，而应用层可以归为用户层。\n物理层\r数据链路层\r网络层\r传输层\r应用层\r总结\r\r 字面意思解释：物理传输、硬件、物理特性。狭义意思可以是光缆、电缆、双绞线和无线电波这些传输介质、物理接口，中间传的是电信号或光信号 \r\r 标志网络中的各主机（主机编码问题，例如MAC地址） 从信号所表示的一串比特流中区分出地址和数据 协调各主机争用总线\n \r\r 标志各网络以及网络中的各主机（网络和主机共同编址的问题，例如IP地址） 路由器如何转发分组，如何进行路由选择\n \r\r  传输层是负责在会话进程之间建和维护端——端连接的，实现网络环境中分布式通信。\n  解决进程之间基于网络的通信问题\n  出现传输错误时，如何处理\n  \r 通过应用进程间的交互来完成特定的网络应用\n \r\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"41ff45eac6c30962\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r\n  OSI体系结构  OSI体系结构的七层分别为：应用层、传输层、网络层、数据链路层、会话层、表示层、物理层  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":45,"section":"posts","tags":["网络协议"],"title":"计算机网络概述","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"content":"链路层  参考：《TCP/IP详解 卷1：协议》\nB站UP：湖科大教书匠 https://space.bilibili.com/360996402/\n 链路层概念  沿着通信路劲连接相邻节点（运行链路层协议的任何设备称为“节点“包括主机，路由器和交换机等）的通信信道称为链路（link）。  链路层协议提供的服务  成帧（framing）：网络层数据报经链路层发送前，链路层协议将其用链路层帧封装起来； 链路接入：媒体访问控制（Medium Access Control，MAC）协议规定了帧在链路上的传输规则； 可靠交付：保证无差错地经链路层移动每个网络层数据报； 差错检测和纠正。  链路层在何处实现  链路层的主体部分在网络适配器（network adapter）中实现的。  差错检测与纠正计数 奇偶校验  发送的信息D有d个比特，发送时附加一个比特，选择它的值使得这d+1个比特中“1”的总数是偶数； 更常用的是二维奇偶校验：将d个比特划分为i行j列,对每行和每列计算奇偶值，产生的i+j+1个奇偶比特构成了链路层帧的差错检测比特； 这种接收方检测和纠正差错的能力被称为前向纠错（Forward Error Correction，FEC）  检验和方法  对数据的字节作为16比特的整数并求和，接收方对数据和求反码，检测其结果是否全为1，如果这些比特有任何比特为0，表示出差错。  循环冗余检测CRC  CRC又被称为多项式编码，接收方用生成的多项式G去除接收到的d+r比特，如果余数为0表示未出错，否则认为数据未正确发送。  多路访问链路和协议  多路访问协议（mutiple access protocol）:节点通过这些协议来规范他们在共享的广播信道上的传输行为。  信道划分协议  时分多路复用（TDM）  优点：  消除了碰撞，而且非常公平；   缺点：  各个结点的速率被限制在了R/N bps的平均速率，即时它是唯一要发送分组的结点。     频分多路复用（FDM）  优缺点同TDM   码分多址（Code Division Mutiple Access,CDMA）  CDMA对每个结点分配一种不同的编码，然后每个结点用它唯一的编码来对它发送的数据进行编码。    随机接入协议  在此协议中，一个传输结点总是以信道的全部速率R进行发送，当有碰撞时，涉及到的结点反复的重发，知道该分组五无碰撞的通过为止； 随机接入协议有时隙ALOHA，ALOHA，载波侦听多路访问（CSMA），具有碰撞检测的载波侦听多路访问（CSMA/DA）。  轮流协议  主要协议有轮询协议（polling protocol）和令牌传递协议（token-passing protocol)。  DOCSIS  这是用于电缆因特网接入的链路层协议  交换局域网 链路层寻址和ARP  链路层地址有多种称呼：LAN地址（LAN adress）、物理地址（physical address）和MAC地址（MAC address），其中MAC地址最常用； 因为网络层地址（如IP地址）和链路层地址（MAC地址）之间需要互相转换，所以需要地址解析协议（Address Resolution Protocol，ARP）； ARP只能在同一个子网下的主机和路由器接口解析IP地址； 当需要发送数据到外网时，首先通过IP寻址找到目的主机子网的路由器，再通过这路由器用ARP找到目的MAC地址的主机。  以太网  所有的以太网技术都向网络层提供无连接服务，也就是说当适配器A要向适配器B发送一个数据报时，适配器A在一个以太网帧中封装该数据报，并把该帧发送到局域网上，没有先与适配器B握手。  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":46,"section":"posts","tags":["网络协议"],"title":"链路层协议","uri":"https://mrxiaoling.github.io/en/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"content":"synchronized关键字  对象锁和类锁： https://blog.csdn.net/u013142781/article/details/51697672\n  首先要明白synchronized关键字锁定的是对象，而不是代码块！，这个对象可以自己指定；  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class T {\rprivate int count = 10;\rprivate Object o = new Object();\rpublic void m() {\rsynchronized(o) {\r//任何线程要执行下面的代码，必须先拿到o的锁\r\tcount--;\rSystem.out.println(Thread.currentThread().getName() + \u0026#34; count = \u0026#34; + count);\r}\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class T {\rprivate int count = 10;\rpublic synchronized void m() {\r//等同于在方法的代码执行时要synchronized(this)\r //这里锁定是class对象\r\tcount--;\rSystem.out.println(Thread.currentThread().getName() + \u0026#34; count = \u0026#34; + count);\r}\r/**\r* public void m() {\r* synchronized(this) {\r* //任何线程要执行下面的代码，必须先拿到this的锁\r* count--;\r* System.out.println(Thread.currentThread().getName() + \u0026#34; count = \u0026#34; + count);\r* }* }\r*/\r}\r   在实例方法上锁定的是对象，用在静态方法锁定的是class对象  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class T {\rprivate static int count = 10;\rpublic synchronized static void m() { //这里等同于synchronized(yxxy.c_004.T.class)\r\tcount--;\rSystem.out.println(Thread.currentThread().getName() + \u0026#34; count = \u0026#34; + count);\r}\rpublic static void mm() {\rsynchronized(T.class) {\r//考虑一下这里写synchronized(this)是否可以？\r\t//答案是不可以\r\t//因为静态类和静态方法是需要通过new出对象就可以访问的，这时候是没有this引用的\r\tcount --;\r}\r}\r}\r    同步和非同步方法是否可以同时调用？\n  可以！\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class T {\rpublic synchronized void m1() { System.out.println(Thread.currentThread().getName() + \u0026#34; m1 start...\u0026#34;);\rtry {\rThread.sleep(10000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(Thread.currentThread().getName() + \u0026#34; m1 end\u0026#34;);\r}\rpublic void m2() {\rtry {\rThread.sleep(5000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(Thread.currentThread().getName() + \u0026#34; m2 \u0026#34;);\r}\rpublic static void main(String[] args) {\rT t = new T();\rnew Thread(t::m1, \u0026#34;t1\u0026#34;).start();\rnew Thread(t::m2, \u0026#34;t2\u0026#34;).start();\r}\r}\r   对业务写方法加锁,对业务读方法不加锁,容易产生脏读问题（dirtyRead)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public class Account {\rString name;\rdouble balance;\rpublic synchronized void set(String name, double balance) {\rthis.name = name;\rtry {\r//中断，模拟现实特定场景\r\tThread.sleep(2000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rthis.balance = balance;\r}\rpublic /*synchronized*/ double getBalance(String name) {\rreturn this.balance;\r}\rpublic static void main(String[] args) {\rAccount a = new Account();\rnew Thread(()-\u0026gt;a.set(\u0026#34;zhangsan\u0026#34;, 100.0)).start();\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(a.getBalance(\u0026#34;zhangsan\u0026#34;));\rtry {\rTimeUnit.SECONDS.sleep(2);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(a.getBalance(\u0026#34;zhangsan\u0026#34;));\r}\r}\r   一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁,也就是说synchronized获得的锁是可重入的  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class T {\rsynchronized void m1() {\rSystem.out.println(\u0026#34;m1 start\u0026#34;);\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r//还有可能是子类调用父类的同步方法，synchronized获得锁一样是可重入的\r\tm2();\r}\rsynchronized void m2() {\rtry {\rTimeUnit.SECONDS.sleep(2);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(\u0026#34;m2\u0026#34;);\r}\r}\r   程序在执行过程中，如果出现异常，默认情况锁会被释放，所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。因此要非常小心的处理同步业务逻辑中的异常。 不要以字符串常量作为锁定对象，在下面的例子中，m1和m2其实锁定的是同一个对象，这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，但是你读不到源码，所以你在自己的代码中也锁定了\u0026quot;Hello\u0026rdquo;,这时候就有可能发生非常诡异的死锁阻塞，因为你的程序和你用到的类库不经意间使用了同一把锁  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class T {\rString s1 = \u0026#34;Hello\u0026#34;;\rString s2 = \u0026#34;Hello\u0026#34;;\rvoid m1() {\rsynchronized(s1) {\r}\r}\rvoid m2() {\rsynchronized(s2) {\r}\r}\r}\r  Volatile关键字  java内存模型： https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html\n  volatile 关键字，使一个变量在多个线程间可见； A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道,用volatile关键字，会让所有线程都会读到变量的修改值; 在下面的代码中，running是存在于堆内存的t对象中,当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行; 使用volatile，将会强制所有线程都去堆内存中读取running的值; volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public class T {\r/*volatile*/ boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别\r\tvoid m() {\rSystem.out.println(\u0026#34;m start\u0026#34;);\rwhile(running) {\r/*\rtry {\rTimeUnit.MILLISECONDS.sleep(10);\r} catch (InterruptedException e) {\re.printStackTrace();\r}*/\r}\rSystem.out.println(\u0026#34;m end!\u0026#34;);\r}\rpublic static void main(String[] args) {\rT t = new T();\rnew Thread(t::m, \u0026#34;t1\u0026#34;).start();\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rt.running = false;\r}\r}\r   volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public class T {\rvolatile int count = 0; void m() {\rfor(int i=0; i\u0026lt;10000; i++) count++;\r}\rpublic static void main(String[] args) {\rT t = new T();\rList\u0026lt;Thread\u0026gt; threads = new ArrayList\u0026lt;Thread\u0026gt;();\rfor(int i=0; i\u0026lt;10; i++) {\rthreads.add(new Thread(t::m, \u0026#34;thread-\u0026#34;+i));\r}\tthreads.forEach((o)-\u0026gt;o.start());\rthreads.forEach((o)-\u0026gt;{\rtry {\ro.join();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r});\rSystem.out.println(t.count);\r}\r}\r   锁的信息是记录在堆内存里的， 锁定某对象o，如果o的属性发生改变，不影响锁的使用，但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class T {\rObject o = new Object();\rvoid m() {\rsynchronized(o) {\rwhile(true) {\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(Thread.currentThread().getName());\r}\r}\r}\rpublic static void main(String[] args) {\rT t = new T();\r//启动第一个线程\r\tnew Thread(t::m, \u0026#34;t1\u0026#34;).start();\rtry {\rTimeUnit.SECONDS.sleep(3);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r//创建第二个线程\r\tThread t2 = new Thread(t::m, \u0026#34;t2\u0026#34;);\rt.o = new Object(); //锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会\r\tt2.start();\r}\r   不要以字符串常量作为锁定对象在下面的例子中，m1和m2其实锁定的是同一个对象，这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，但是你读不到源码，所以你在自己的代码中也锁定了\u0026quot;Hello\u0026rdquo;,这时候就有可能发生非常诡异的死锁阻塞， 因为你的程序和你用到的类库不经意间使用了同一把锁  面试题：  实现一个容器，提供两个方法，add，size，写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束。  分析下面这个程序，能完成这个功能吗？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  public class MyContainer1 {\rList lists = new ArrayList();\r//加上volatile关键字可以，但是不是最好的解决办法\r //给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu\r\t//volatile List lists = new ArrayList();\r\tpublic void add(Object o) {\rlists.add(o);\r}\rpublic int size() {\rreturn lists.size();\r}\rpublic static void main(String[] args) {\rMyContainer1 c = new MyContainer1();\rnew Thread(() -\u0026gt; {\rfor(int i=0; i\u0026lt;10; i++) {\rc.add(new Object());\rSystem.out.println(\u0026#34;add \u0026#34; + i);\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}, \u0026#34;t1\u0026#34;).start();\rnew Thread(() -\u0026gt; {\rwhile(true) {\rif(c.size() == 5) {\rbreak;\r}\r}\rSystem.out.println(\u0026#34;t2 结束\u0026#34;);\r}, \u0026#34;t2\u0026#34;).start();\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  public class MyContainer3 {\r//添加volatile，使t2能够得到通知\r\tvolatile List lists = new ArrayList();\rpublic void add(Object o) {\rlists.add(o);\r}\rpublic int size() {\rreturn lists.size();\r}\rpublic static void main(String[] args) {\rMyContainer3 c = new MyContainer3();\rfinal Object lock = new Object();\rnew Thread(() -\u0026gt; {\rsynchronized(lock) {\rSystem.out.println(\u0026#34;t2启动\u0026#34;);\rif(c.size() != 5) {\rtry {\rlock.wait();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\rSystem.out.println(\u0026#34;t2 结束\u0026#34;);\r}\r}, \u0026#34;t2\u0026#34;).start();\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e1) {\re1.printStackTrace();\r}\rnew Thread(() -\u0026gt; {\rSystem.out.println(\u0026#34;t1启动\u0026#34;);\rsynchronized(lock) {\rfor(int i=0; i\u0026lt;10; i++) {\rc.add(new Object());\rSystem.out.println(\u0026#34;add \u0026#34; + i);\rif(c.size() == 5) {\rlock.notify();\r}\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}, \u0026#34;t1\u0026#34;).start();\t}\r}\r   这里使用wait和notify做到，wait会释放锁，而notify不会释放锁, 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  /**\r* 曾经的面试题：（淘宝？）\r* 实现一个容器，提供两个方法，add，size\r* 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束\r* * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，该怎么做呢？\r* * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁\r* 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以\r* * 阅读下面的程序，并分析输出结果\r* 可以读到输出结果并不是size=5时t2退出，而是t1结束时t2才接收到通知而退出\r* 想想这是为什么？\r* * notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行\r* 整个通信过程比较繁琐\r* @author mashibing\r*/\rpackage yxxy.c_019;\rimport java.util.ArrayList;\rimport java.util.List;\rimport java.util.concurrent.TimeUnit;\rpublic class MyContainer4 {\r//添加volatile，使t2能够得到通知\r\tvolatile List lists = new ArrayList();\rpublic void add(Object o) {\rlists.add(o);\r}\rpublic int size() {\rreturn lists.size();\r}\rpublic static void main(String[] args) {\rMyContainer4 c = new MyContainer4();\rfinal Object lock = new Object();\rnew Thread(() -\u0026gt; {\rsynchronized(lock) {\rSystem.out.println(\u0026#34;t2启动\u0026#34;);\rif(c.size() != 5) {\rtry {\rlock.wait();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\rSystem.out.println(\u0026#34;t2 结束\u0026#34;);\r//通知t1继续执行\r\tlock.notify();\r}\r}, \u0026#34;t2\u0026#34;).start();\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e1) {\re1.printStackTrace();\r}\rnew Thread(() -\u0026gt; {\rSystem.out.println(\u0026#34;t1启动\u0026#34;);\rsynchronized(lock) {\rfor(int i=0; i\u0026lt;10; i++) {\rc.add(new Object());\rSystem.out.println(\u0026#34;add \u0026#34; + i);\rif(c.size() == 5) {\rlock.notify();\r//释放锁，让t2得以执行\r\ttry {\rlock.wait();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}, \u0026#34;t1\u0026#34;).start();\r}\r}\r   改进：notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行; 整个通信过程比较繁琐； 使用Latch（门闩）替代wait notify来进行通知，好处是通信方式简单，同时也可以指定等待时间，使用await和countdown方法替代wait和notify， CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行，当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了这时应该考虑countdownlatch/cyclicbarrier/semaphore   CountDownLatch、CyclicBarrier和Semaphore:https://www.cnblogs.com/dolphin0520/p/3920397.html\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  public class MyContainer5 {\r// 添加volatile，使t2能够得到通知\r\tvolatile List lists = new ArrayList();\rpublic void add(Object o) {\rlists.add(o);\r}\rpublic int size() {\rreturn lists.size();\r}\rpublic static void main(String[] args) {\rMyContainer5 c = new MyContainer5();\rCountDownLatch latch = new CountDownLatch(1);\rnew Thread(() -\u0026gt; {\rSystem.out.println(\u0026#34;t2启动\u0026#34;);\rif (c.size() != 5) {\rtry {\rlatch.await();\r//也可以指定等待时间\r\t//latch.await(5000, TimeUnit.MILLISECONDS);\r\t} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\rSystem.out.println(\u0026#34;t2 结束\u0026#34;);\r}, \u0026#34;t2\u0026#34;).start();\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e1) {\re1.printStackTrace();\r}\rnew Thread(() -\u0026gt; {\rSystem.out.println(\u0026#34;t1启动\u0026#34;);\rfor (int i = 0; i \u0026lt; 10; i++) {\rc.add(new Object());\rSystem.out.println(\u0026#34;add \u0026#34; + i);\rif (c.size() == 5) {\r// 打开门闩，让t2得以执行\r\tlatch.countDown();\r}\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}, \u0026#34;t1\u0026#34;).start();\r}\r}\r  ReentrantLock  ReentrantLock原理： https://juejin.im/post/5aeb0a8b518825673a2066f0\n reentrantlock用于替代synchronized  需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）; 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class ReentrantLock2 {\rLock lock = new ReentrantLock();\rvoid m1() {\rtry {\rlock.lock(); //synchronized(this)\r\tfor (int i = 0; i \u0026lt; 10; i++) {\rTimeUnit.SECONDS.sleep(1);\rSystem.out.println(i);\r}\r} catch (InterruptedException e) {\re.printStackTrace();\r} finally {\rlock.unlock();\r}\r}\rvoid m2() {\rlock.lock();\rSystem.out.println(\u0026#34;m2 ...\u0026#34;);\rlock.unlock();\r}\rpublic static void main(String[] args) {\rReentrantLock2 rl = new ReentrantLock2();\rnew Thread(rl::m1).start();\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rnew Thread(rl::m2).start();\r}\r   tryLock()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public class ReentrantLock3 {\rLock lock = new ReentrantLock();\rvoid m1() {\rtry {\rlock.lock();\rfor (int i = 0; i \u0026lt; 10; i++) {\rTimeUnit.SECONDS.sleep(1);\rSystem.out.println(i);\r}\r} catch (InterruptedException e) {\re.printStackTrace();\r} finally {\rlock.unlock();\r}\r}\r/**\r* 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行\r* 可以根据tryLock的返回值来判定是否锁定\r* 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中\r*/\rvoid m2() {\r/*\rboolean locked = lock.tryLock();\rSystem.out.println(\u0026#34;m2 ...\u0026#34; + locked);\rif(locked) lock.unlock();\r*/\rboolean locked = false;\rtry {\rlocked = lock.tryLock(5, TimeUnit.SECONDS);\rSystem.out.println(\u0026#34;m2 ...\u0026#34; + locked);\r} catch (InterruptedException e) {\re.printStackTrace();\r} finally {\rif(locked) lock.unlock();\r}\r}\rpublic static void main(String[] args) {\rReentrantLock3 rl = new ReentrantLock3();\rnew Thread(rl::m1).start();\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rnew Thread(rl::m2).start();\r}\r}\r   lock()与lockInterruptibly()的区别: https://blog.csdn.net/pange1991/article/details/82219997\n   lock 与 lockInterruptibly比较区别在于：\n  lock 优先考虑获取锁，待获取锁成功后，才响应中断。\n  lockInterruptibly 优先考虑响应中断，而不是响应锁的普通获取或重入获取。\n  详细区别：\nReentrantLock.lockInterruptibly允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个InterruptedException。 ReentrantLock.lock方法不允许Thread.interrupt中断,即使检测到Thread.isInterrupted,一样会继续尝试获取锁，失败则继续休眠。只是在最后获取锁成功后再把当前线程置为interrupted状态,然后再中断线程。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class MyThread05 extends Thread {\rpublic void test3() throws Exception {\rfinal Lock lock = new ReentrantLock();\rlock.lock();\rThread.sleep(1000);\rThread t1 = new Thread(new Runnable() {\r@Override\rpublic void run() {\r// lock.lock();\r try {\rlock.lockInterruptibly();\r} catch (InterruptedException e) {\r// TODO Auto-generated catch block\r e.printStackTrace();\r} finally {\rSystem.out.println(((ReentrantLock) lock).isLocked());\r}\rSystem.out.println(Thread.currentThread().getName() + \u0026#34; interrupted.\u0026#34;);\r}\r});\rt1.start();\rThread.sleep(1000);\rt1.interrupt();\rThread.sleep(1000000);\r}\rpublic static void main(String[] args) throws Exception {\rMyThread05 thread = new MyThread05();\rthread.test3();\r}\r}\r  输出：\njava.lang.InterruptedException\rat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)\rat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)\rat java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)\rat yxxy.c_020.MyThread05$1.run(MyThread05.java:16)\rat java.lang.Thread.run(Thread.java:748)\rtrue\rThread-1 interrupted.\r生产者消费者模型  虚假唤醒： https://juejin.im/post/5d32a6545188257f3850d514\n 面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  /**\r*方法1：使用wait和notify/notifyAll来实现\r*/\rpublic class MyContainer1\u0026lt;T\u0026gt; {\rfinal private LinkedList\u0026lt;T\u0026gt; lists = new LinkedList\u0026lt;\u0026gt;();\rfinal private int MAX = 10; //最多10个元素\r\tprivate int count = 0;\rpublic synchronized void put(T t) {\rwhile(lists.size() == MAX) { //想想为什么用while而不是用if？\r //虚假唤醒问题\r\ttry {\rthis.wait(); //effective java\r\t} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\rlists.add(t);\r++count;\rthis.notifyAll(); //通知消费者线程进行消费\r\t}\rpublic synchronized T get() {\rT t = null;\rwhile(lists.size() == 0) {\rtry {\rthis.wait();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\rt = lists.removeFirst();\rcount --;\rthis.notifyAll(); //通知生产者进行生产\r\treturn t;\r}\rpublic static void main(String[] args) {\rMyContainer1\u0026lt;String\u0026gt; c = new MyContainer1\u0026lt;\u0026gt;();\r//启动消费者线程\r\tfor(int i=0; i\u0026lt;10; i++) {\rnew Thread(()-\u0026gt;{\rfor(int j=0; j\u0026lt;5; j++) System.out.println(c.get());\r}, \u0026#34;c\u0026#34; + i).start();\r}\rtry {\rTimeUnit.SECONDS.sleep(2);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r//启动生产者线程\r\tfor(int i=0; i\u0026lt;2; i++) {\rnew Thread(()-\u0026gt;{\rfor(int j=0; j\u0026lt;25; j++) c.put(Thread.currentThread().getName() + \u0026#34; \u0026#34; + j);\r}, \u0026#34;p\u0026#34; + i).start();\r}\r}\r}\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  /**\r*方法2：使用Lock和Condition来实现\r*对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒\r*/\rpublic class MyContainer2\u0026lt;T\u0026gt; {\rfinal private LinkedList\u0026lt;T\u0026gt; lists = new LinkedList\u0026lt;\u0026gt;();\rfinal private int MAX = 10; //最多10个元素\r\tprivate int count = 0;\rprivate Lock lock = new ReentrantLock();\rprivate Condition producer = lock.newCondition();\rprivate Condition consumer = lock.newCondition();\rpublic void put(T t) {\rtry {\rlock.lock();\rwhile(lists.size() == MAX) { //想想为什么用while而不是用if？\r\tproducer.await();\r}\rlists.add(t);\r++count;\rconsumer.signalAll(); //通知消费者线程进行消费\r\t} catch (InterruptedException e) {\re.printStackTrace();\r} finally {\rlock.unlock();\r}\r}\rpublic T get() {\rT t = null;\rtry {\rlock.lock();\rwhile(lists.size() == 0) {\rconsumer.await();\r}\rt = lists.removeFirst();\rcount --;\rproducer.signalAll(); //通知生产者进行生产\r\t} catch (InterruptedException e) {\re.printStackTrace();\r} finally {\rlock.unlock();\r}\rreturn t;\r}\rpublic static void main(String[] args) {\rMyContainer2\u0026lt;String\u0026gt; c = new MyContainer2\u0026lt;\u0026gt;();\r//启动消费者线程\r\tfor(int i=0; i\u0026lt;10; i++) {\rnew Thread(()-\u0026gt;{\rfor(int j=0; j\u0026lt;5; j++) System.out.println(c.get());\r}, \u0026#34;c\u0026#34; + i).start();\r}\rtry {\rTimeUnit.SECONDS.sleep(2);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r//启动生产者线程\r\tfor(int i=0; i\u0026lt;2; i++) {\rnew Thread(()-\u0026gt;{\rfor(int j=0; j\u0026lt;25; j++) c.put(Thread.currentThread().getName() + \u0026#34; \u0026#34; + j);\r}, \u0026#34;p\u0026#34; + i).start();\r}\r}\r}\r  单例的多线程安全  https://blog.csdn.net/mnb65482/article/details/80458571\n 类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。\n1.遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。\n5.当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\u0026quot;有且仅有\u0026rdquo;，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n我们再回头看下getInstance()方法，调用的是SingleTonHoler.INSTANCE，取的是SingleTonHoler里的INSTANCE对象，跟上面那个DCL方法不同的是，getInstance()方法并没有多次去new对象，故不管多少个线程去调用getInstance()方法，取的都是同一个INSTANCE对象，而不用去重新创建。当getInstance()方法被调用时，SingleTonHoler才在SingleTon的运行时常量池里，把符号引用替换为直接引用，这时静态对象INSTANCE也真正被创建，然后再被getInstance()方法返回出去，这点同饿汉模式。那么INSTANCE在创建过程中又是如何保证线程安全的呢？在《深入理解JAVA虚拟机》中，有这么一句话:\n虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行()方法后，其他线程唤醒之后不会再次进入()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。\n故而，可以看出INSTANCE在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，我们创建单例时，可以在静态内部类与DCL模式里自己斟酌。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /**\r* 线程安全的单例模式：\r* 更好的是采用下面的方式，既不用加锁，也能实现懒加载\r*/\rpublic class Singleton {\rprivate Singleton() {\rSystem.out.println(\u0026#34;single\u0026#34;);\r}\rprivate static class Inner {\rprivate static Singleton s = new Singleton();\r}\rpublic static Singleton getSingle() {\rreturn Inner.s;\r}\rpublic static void main(String[] args) {\rThread[] ths = new Thread[200];\rfor(int i=0; i\u0026lt;ths.length; i++) {\rths[i] = new Thread(()-\u0026gt;{\rSystem.out.println(Singleton.getSingle());\r});\r}\rArrays.asList(ths).forEach(o-\u0026gt;o.start());\r}\r}\r  面试题：售票问题  有N张火车票，每张票都有一个编号，同时有10个窗口对外售票，请写一个模拟程序。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class TicketSeller1 {\rstatic List\u0026lt;String\u0026gt; tickets = new ArrayList\u0026lt;\u0026gt;();\rstatic {\rfor(int i=0; i\u0026lt;10000; i++) tickets.add(\u0026#34;票编号：\u0026#34; + i);\r}\rpublic static void main(String[] args) {\rfor(int i=0; i\u0026lt;10; i++) {\rnew Thread(()-\u0026gt;{\rwhile(tickets.size() \u0026gt; 0) {\rSystem.out.println(\u0026#34;销售了--\u0026#34; + tickets.remove(0));\r}\r}).start();\r}\r}\r}\r   ArrayList是线程不安全的所以会出现重复销售的问题  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class TicketSeller2 {\rstatic Vector\u0026lt;String\u0026gt; tickets = new Vector\u0026lt;\u0026gt;();\rstatic {\rfor(int i=0; i\u0026lt;1000; i++) tickets.add(\u0026#34;票 编号：\u0026#34; + i);\r}\rpublic static void main(String[] args) {\rfor(int i=0; i\u0026lt;10; i++) {\rnew Thread(()-\u0026gt;{\rwhile(tickets.size() \u0026gt; 0) {\rtry {\rTimeUnit.MILLISECONDS.sleep(10);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(\u0026#34;销售了--\u0026#34; + tickets.remove(0));\r}\r}).start();\r}\r}\r}\r   上面的程序虽然使用了Vector线程安全类，但是线程业务代码中，判断size和减票这两个操作不是原子操作，是可分得，所以还是会出现线程安全问题，导致数组越界问题  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public class TicketSeller3 {\rstatic List\u0026lt;String\u0026gt; tickets = new LinkedList\u0026lt;\u0026gt;();\rstatic {\rfor(int i=0; i\u0026lt;1000; i++) tickets.add(\u0026#34;票 编号：\u0026#34; + i);\r}\rpublic static void main(String[] args) {\rfor(int i=0; i\u0026lt;10; i++) {\rnew Thread(()-\u0026gt;{\rwhile(true) {\rsynchronized(tickets) {\rif(tickets.size() \u0026lt;= 0) break;\rtry {\rTimeUnit.MILLISECONDS.sleep(10);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(\u0026#34;销售了--\u0026#34; + tickets.remove(0));\r}\r}\r}).start();\r}\r}\r}\r   就算操作A和B都是同步的，但A和B组成的复合操作也未必是同步的，仍然需要自己进行同步，就像这个程序，判断size和进行remove必须是一整个的原子操作  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class TicketSeller4 {\rstatic Queue\u0026lt;String\u0026gt; tickets = new ConcurrentLinkedQueue\u0026lt;\u0026gt;();\rstatic {\rfor(int i=0; i\u0026lt;1000; i++) tickets.add(\u0026#34;票 编号：\u0026#34; + i);\r}\rpublic static void main(String[] args) {\tfor(int i=0; i\u0026lt;10; i++) {\rnew Thread(()-\u0026gt;{\rwhile(true) {\rString s = tickets.poll();\rif(s == null) break;\relse System.out.println(\u0026#34;销售了--\u0026#34; + s);\r}\r}).start();\r}\r}\r}\r   上面的程序则是使用ConcurrentQueue提高并发性  JUC  JUC之AQS： https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70\n ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":47,"section":"posts","tags":["多线程"],"title":"马士兵多线程笔记","uri":"https://mrxiaoling.github.io/en/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%A9%AC%E5%A3%AB%E5%85%B5%E5%A4%9A%E7%BA%BF%E7%A8%8B1/"}]